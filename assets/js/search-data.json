{
  
    
  
    
        "post1": {
            "title": "SatFootprint:  Foot Print Detection of Buildings in Satellite Images",
            "content": "Introduction . In this notebook I implement a neural network based solution for building footprint detection on the SpaceNet7 dataset. I ignore the temporal aspect of the orginal challenge and focus on performing segmentation to detect buildings on single images. I use fastai, a deep learning library based on PyTorch. It provides functionality to train neural networks with modern best practices while reducing the amount of boilerplate code required. . Dataset Downloading . from google.colab import drive drive.mount(&#39;/content/gdrive&#39;) . Mounted at /content/gdrive . cd /content/gdrive/Shareddrives/Undrive . /content/gdrive/Shareddrives/Undrive . # !unzip spacenet-7-multitemporal-urban-development.zip -d s7 . START . The dataset is stored on AWS. Instructions how to install are here. . Installing Libraries and Preparing requirements.txt for reproducbillity . . !pip freeze &gt; requirements.txt . ls . models/ s7/ wandb/ requirements.txt spacenet-7-multitemporal-urban-development.zip . Setup . cd /content/gdrive/Shareddrives/Undrive/s7/SN7_buildings_train/train/ . /content/gdrive/Shareddrives/Undrive/s7/SN7_buildings_train/train . . !ls . L15-0331E-1257N_1327_3160_13 L15-1203E-1203N_4815_3378_13 L15-0357E-1223N_1429_3296_13 L15-1204E-1202N_4816_3380_13 L15-0358E-1220N_1433_3310_13 L15-1204E-1204N_4819_3372_13 L15-0361E-1300N_1446_2989_13 L15-1209E-1113N_4838_3737_13 L15-0368E-1245N_1474_3210_13 L15-1210E-1025N_4840_4088_13 L15-0387E-1276N_1549_3087_13 L15-1276E-1107N_5105_3761_13 L15-0434E-1218N_1736_3318_13 L15-1289E-1169N_5156_3514_13 L15-0457E-1135N_1831_3648_13 L15-1296E-1198N_5184_3399_13 L15-0487E-1246N_1950_3207_13 L15-1298E-1322N_5193_2903_13 L15-0506E-1204N_2027_3374_13 L15-1335E-1166N_5342_3524_13 L15-0544E-1228N_2176_3279_13 L15-1389E-1284N_5557_3054_13 L15-0566E-1185N_2265_3451_13 L15-1438E-1134N_5753_3655_13 L15-0571E-1075N_2287_3888_13 L15-1439E-1134N_5759_3655_13 L15-0577E-1243N_2309_3217_13 L15-1479E-1101N_5916_3785_13 L15-0586E-1127N_2345_3680_13 L15-1481E-1119N_5927_3715_13 L15-0595E-1278N_2383_3079_13 L15-1538E-1163N_6154_3539_13 L15-0614E-0946N_2459_4406_13 L15-1615E-1205N_6460_3370_13 L15-0632E-0892N_2528_4620_13 L15-1615E-1206N_6460_3366_13 L15-0683E-1006N_2732_4164_13 L15-1617E-1207N_6468_3360_13 L15-0760E-0887N_3041_4643_13 L15-1669E-1153N_6678_3579_13 L15-0924E-1108N_3699_3757_13 L15-1669E-1160N_6678_3548_13 L15-0977E-1187N_3911_3441_13 L15-1669E-1160N_6679_3549_13 L15-1014E-1375N_4056_2688_13 L15-1672E-1207N_6691_3363_13 L15-1015E-1062N_4061_3941_13 L15-1690E-1211N_6763_3346_13 L15-1025E-1366N_4102_2726_13 L15-1691E-1211N_6764_3347_13 L15-1049E-1370N_4196_2710_13 L15-1703E-1219N_6813_3313_13 L15-1138E-1216N_4553_3325_13 L15-1709E-1112N_6838_3742_13 L15-1172E-1306N_4688_2967_13 L15-1716E-1211N_6864_3345_13 L15-1185E-0935N_4742_4450_13 models L15-1200E-0847N_4802_4803_13 wandb . . L15-0331E-1257N_1327_3160_13 L15-1200E-0847N_4802_4803_13 L15-0357E-1223N_1429_3296_13 L15-1203E-1203N_4815_3378_13 L15-0358E-1220N_1433_3310_13 L15-1204E-1202N_4816_3380_13 L15-0361E-1300N_1446_2989_13 L15-1204E-1204N_4819_3372_13 L15-0368E-1245N_1474_3210_13 L15-1209E-1113N_4838_3737_13 L15-0387E-1276N_1549_3087_13 L15-1210E-1025N_4840_4088_13 L15-0434E-1218N_1736_3318_13 L15-1276E-1107N_5105_3761_13 L15-0457E-1135N_1831_3648_13 L15-1289E-1169N_5156_3514_13 L15-0487E-1246N_1950_3207_13 L15-1296E-1198N_5184_3399_13 L15-0506E-1204N_2027_3374_13 L15-1298E-1322N_5193_2903_13 L15-0544E-1228N_2176_3279_13 L15-1335E-1166N_5342_3524_13 L15-0566E-1185N_2265_3451_13 L15-1389E-1284N_5557_3054_13 L15-0571E-1075N_2287_3888_13 L15-1438E-1134N_5753_3655_13 L15-0577E-1243N_2309_3217_13 L15-1439E-1134N_5759_3655_13 L15-0586E-1127N_2345_3680_13 L15-1479E-1101N_5916_3785_13 L15-0595E-1278N_2383_3079_13 L15-1481E-1119N_5927_3715_13 L15-0614E-0946N_2459_4406_13 L15-1538E-1163N_6154_3539_13 L15-0632E-0892N_2528_4620_13 L15-1615E-1205N_6460_3370_13 L15-0683E-1006N_2732_4164_13 L15-1615E-1206N_6460_3366_13 L15-0760E-0887N_3041_4643_13 L15-1617E-1207N_6468_3360_13 L15-0924E-1108N_3699_3757_13 L15-1669E-1153N_6678_3579_13 L15-0977E-1187N_3911_3441_13 L15-1669E-1160N_6678_3548_13 L15-1014E-1375N_4056_2688_13 L15-1669E-1160N_6679_3549_13 L15-1015E-1062N_4061_3941_13 L15-1672E-1207N_6691_3363_13 L15-1025E-1366N_4102_2726_13 L15-1690E-1211N_6763_3346_13 L15-1049E-1370N_4196_2710_13 L15-1691E-1211N_6764_3347_13 L15-1138E-1216N_4553_3325_13 L15-1703E-1219N_6813_3313_13 L15-1172E-1306N_4688_2967_13 L15-1709E-1112N_6838_3742_13 L15-1185E-0935N_4742_4450_13 L15-1716E-1211N_6864_3345_13 . path.ls() . (#59) [Path(&#39;L15-0331E-1257N_1327_3160_13&#39;),Path(&#39;L15-0357E-1223N_1429_3296_13&#39;),Path(&#39;L15-0358E-1220N_1433_3310_13&#39;),Path(&#39;L15-0361E-1300N_1446_2989_13&#39;),Path(&#39;L15-0368E-1245N_1474_3210_13&#39;),Path(&#39;L15-0387E-1276N_1549_3087_13&#39;),Path(&#39;L15-0434E-1218N_1736_3318_13&#39;),Path(&#39;L15-0457E-1135N_1831_3648_13&#39;),Path(&#39;L15-0487E-1246N_1950_3207_13&#39;),Path(&#39;L15-0506E-1204N_2027_3374_13&#39;)...] . Defining training parameters: . cd /content/gdrive/Shareddrives/Undrive/s7/SN7_buildings_train/train . /content/gdrive/Shareddrives/Undrive/s7/SN7_buildings_train/train . ls . L15-0331E-1257N_1327_3160_13/ L15-1200E-0847N_4802_4803_13/ L15-0357E-1223N_1429_3296_13/ L15-1203E-1203N_4815_3378_13/ L15-0358E-1220N_1433_3310_13/ L15-1204E-1202N_4816_3380_13/ L15-0361E-1300N_1446_2989_13/ L15-1204E-1204N_4819_3372_13/ L15-0368E-1245N_1474_3210_13/ L15-1209E-1113N_4838_3737_13/ L15-0387E-1276N_1549_3087_13/ L15-1210E-1025N_4840_4088_13/ L15-0434E-1218N_1736_3318_13/ L15-1276E-1107N_5105_3761_13/ L15-0457E-1135N_1831_3648_13/ L15-1289E-1169N_5156_3514_13/ L15-0487E-1246N_1950_3207_13/ L15-1296E-1198N_5184_3399_13/ L15-0506E-1204N_2027_3374_13/ L15-1298E-1322N_5193_2903_13/ L15-0544E-1228N_2176_3279_13/ L15-1335E-1166N_5342_3524_13/ L15-0566E-1185N_2265_3451_13/ L15-1389E-1284N_5557_3054_13/ L15-0571E-1075N_2287_3888_13/ L15-1438E-1134N_5753_3655_13/ L15-0577E-1243N_2309_3217_13/ L15-1439E-1134N_5759_3655_13/ L15-0586E-1127N_2345_3680_13/ L15-1479E-1101N_5916_3785_13/ L15-0595E-1278N_2383_3079_13/ L15-1481E-1119N_5927_3715_13/ L15-0614E-0946N_2459_4406_13/ L15-1538E-1163N_6154_3539_13/ L15-0632E-0892N_2528_4620_13/ L15-1615E-1205N_6460_3370_13/ L15-0683E-1006N_2732_4164_13/ L15-1615E-1206N_6460_3366_13/ L15-0760E-0887N_3041_4643_13/ L15-1617E-1207N_6468_3360_13/ L15-0924E-1108N_3699_3757_13/ L15-1669E-1153N_6678_3579_13/ L15-0977E-1187N_3911_3441_13/ L15-1669E-1160N_6678_3548_13/ L15-1014E-1375N_4056_2688_13/ L15-1669E-1160N_6679_3549_13/ L15-1015E-1062N_4061_3941_13/ L15-1672E-1207N_6691_3363_13/ L15-1025E-1366N_4102_2726_13/ L15-1690E-1211N_6763_3346_13/ L15-1049E-1370N_4196_2710_13/ L15-1691E-1211N_6764_3347_13/ L15-1138E-1216N_4553_3325_13/ L15-1703E-1219N_6813_3313_13/ L15-1172E-1306N_4688_2967_13/ L15-1709E-1112N_6838_3742_13/ L15-1185E-0935N_4742_4450_13/ L15-1716E-1211N_6864_3345_13/ . BATCH_SIZE = 12 # (3 for xresnet50, 12 for xresnet34 with Tesla P100/T4) TILES_PER_SCENE = 16 ARCHITECTURE = xresnet34 EPOCHS = 40 CLASS_WEIGHTS = [0.25,0.75] LR_MAX = 3e-4 ENCODER_FACTOR = 10 CODES = [&#39;Land&#39;,&#39;Building&#39;] . # Weights and Biases config config_dictionary = dict( bs=BATCH_SIZE, tiles_per_scene=TILES_PER_SCENE, architecture = str(ARCHITECTURE), epochs = EPOCHS, class_weights = CLASS_WEIGHTS, lr_max = LR_MAX, encoder_factor = ENCODER_FACTOR ) . BATCH_SIZE = 12 # 3 for xresnet50, 12 for xresnet34 with Tesla P100 (16GB) TILES_PER_SCENE = 16 ARCHITECTURE = xresnet34 EPOCHS = 80 CLASS_WEIGHTS = [0.25,0.75] LR_MAX = 3e-4 ENCODER_FACTOR = 10 CODES = [&#39;Land&#39;,&#39;Building&#39;] . BATCH_SIZE = 3 # 3 for xresnet50, 12 for xresnet34 with Tesla P100 (16GB) TILES_PER_SCENE = 16 ARCHITECTURE = xresnet50 EPOCHS = 40 CLASS_WEIGHTS = [0.25,0.75] LR_MAX = 3e-4 ENCODER_FACTOR = 10 CODES = [&#39;Land&#39;,&#39;Building&#39;] . !ls . models s7 wandb requirements.txt spacenet-7-multitemporal-urban-development.zip . Data-Preprocessing . Exploring dataset structure, display sample scene directories: . !nvidia-smi . Tue Jul 6 07:44:58 2021 +--+ | NVIDIA-SMI 465.27 Driver Version: 460.32.03 CUDA Version: 11.2 | |-+-+-+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla T4 Off | 00000000:00:04.0 Off | 0 | | N/A 37C P8 9W / 70W | 3MiB / 15109MiB | 0% Default | | | | N/A | +-+-+-+ +--+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | No running processes found | +--+ . scenes = path.ls().sorted() print(f&#39;Numer of scenes: {len(scenes)}&#39;) pprint(list(scenes)[:5]) . . Numer of scenes: 59 [Path(&#39;.ipynb_checkpoints&#39;), Path(&#39;L15-0331E-1257N_1327_3160_13&#39;), Path(&#39;L15-0357E-1223N_1429_3296_13&#39;), Path(&#39;L15-0358E-1220N_1433_3310_13&#39;), Path(&#39;L15-0361E-1300N_1446_2989_13&#39;)] . Which folders are in each scene (the last three have been added later during processing) . sample_scene = (path/&#39;L15-0683E-1006N_2732_4164_13&#39;) pprint(list(sample_scene.ls())) . . [Path(&#39;L15-0683E-1006N_2732_4164_13/UDM_masks&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/images&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/images_masked&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/labels&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/labels_match&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/labels_match_pix&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/binary_mask&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/img_tiles&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/mask_tiles&#39;)] . How many images are in a specific scene: . images_masked = (sample_scene/&#39;images_masked&#39;).ls().sorted() labels = (sample_scene/&#39;labels_match&#39;).ls().sorted() print(f&#39;Numer of images in scene: {len(images_masked)}&#39;) pprint(list(images_masked[:5])) . . Numer of images in scene: 22 [Path(&#39;L15-0683E-1006N_2732_4164_13/images_masked/global_monthly_2018_01_mosaic_L15-0683E-1006N_2732_4164_13.tif&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/images_masked/global_monthly_2018_02_mosaic_L15-0683E-1006N_2732_4164_13.tif&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/images_masked/global_monthly_2018_03_mosaic_L15-0683E-1006N_2732_4164_13.tif&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/images_masked/global_monthly_2018_04_mosaic_L15-0683E-1006N_2732_4164_13.tif&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/images_masked/global_monthly_2018_06_mosaic_L15-0683E-1006N_2732_4164_13.tif&#39;)] . There are 58 scenes of 4km x 4km in the dataset, each containing about 24 images over the span of two years. . Let&#39;s pick one example image and its polygons: . image, shapes = images_masked[0], labels[0] . We use the images that have UDM masks where clouds were in the original picture: . show_image(PILImage.create(image), figsize=(12,12)); . Creating binary masks . This is a function to generate binary mask images from geojson vector files. Source . import rasterio from rasterio.plot import reshape_as_image import rasterio.mask from rasterio.features import rasterize import pandas as pd import geopandas as gpd from shapely.geometry import mapping, Point, Polygon from shapely.ops import cascaded_union # SOURCE: https://lpsmlgeo.github.io/2019-09-22-binary_mask/ def generate_mask(raster_path, shape_path, output_path=None, file_name=None): &quot;&quot;&quot;Function that generates a binary mask from a vector file (shp or geojson) raster_path = path to the .tif; shape_path = path to the shapefile or GeoJson. output_path = Path to save the binary mask. file_name = Name of the file. &quot;&quot;&quot; #load raster with rasterio.open(raster_path, &quot;r&quot;) as src: raster_img = src.read() raster_meta = src.meta #load o shapefile ou GeoJson train_df = gpd.read_file(shape_path) #Verify crs if train_df.crs != src.crs: print(&quot; Raster crs : {}, Vector crs : {}. n Convert vector and raster to the same CRS.&quot;.format(src.crs,train_df.crs)) #Function that generates the mask def poly_from_utm(polygon, transform): poly_pts = [] poly = cascaded_union(polygon) for i in np.array(poly.exterior.coords): poly_pts.append(~transform * tuple(i)) new_poly = Polygon(poly_pts) return new_poly poly_shp = [] im_size = (src.meta[&#39;height&#39;], src.meta[&#39;width&#39;]) for num, row in train_df.iterrows(): if row[&#39;geometry&#39;].geom_type == &#39;Polygon&#39;: poly = poly_from_utm(row[&#39;geometry&#39;], src.meta[&#39;transform&#39;]) poly_shp.append(poly) else: for p in row[&#39;geometry&#39;]: poly = poly_from_utm(p, src.meta[&#39;transform&#39;]) poly_shp.append(poly) #set_trace() if len(poly_shp) &gt; 0: mask = rasterize(shapes=poly_shp, out_shape=im_size) else: mask = np.zeros(im_size) # Save or show mask mask = mask.astype(&quot;uint8&quot;) bin_mask_meta = src.meta.copy() bin_mask_meta.update({&#39;count&#39;: 1}) if (output_path != None and file_name != None): os.chdir(output_path) with rasterio.open(file_name, &#39;w&#39;, **bin_mask_meta) as dst: dst.write(mask * 255, 1) else: return mask . . Show a mask: . mask = generate_mask(image, shapes) plt.figure(figsize=(12,12)) plt.tight_layout() plt.xticks([]) plt.yticks([]) plt.imshow(mask,cmap=&#39;cividis&#39;); . . . Note: We can see that there - correctly - are no buildings in the mask where the UDM mask is. . Now we create and save a mask file for every image in the &#39;images_masked&#39; folder of every scene. . path.ls() . (#59) [Path(&#39;L15-0331E-1257N_1327_3160_13&#39;),Path(&#39;L15-0357E-1223N_1429_3296_13&#39;),Path(&#39;L15-0358E-1220N_1433_3310_13&#39;),Path(&#39;L15-0361E-1300N_1446_2989_13&#39;),Path(&#39;L15-0368E-1245N_1474_3210_13&#39;),Path(&#39;L15-0387E-1276N_1549_3087_13&#39;),Path(&#39;L15-0434E-1218N_1736_3318_13&#39;),Path(&#39;L15-0457E-1135N_1831_3648_13&#39;),Path(&#39;L15-0487E-1246N_1950_3207_13&#39;),Path(&#39;L15-0506E-1204N_2027_3374_13&#39;)...] . def save_masks(): for scene in tqdm(path.ls().sorted()): for img in (scene/&#39;images_masked&#39;).ls(): shapes = scene/&#39;labels_match&#39;/(img.name[:-4]+&#39;_Buildings.geojson&#39;) if not os.path.exists(scene/&#39;binary_mask&#39;/img.name): if not os.path.exists(scene/&#39;binary_mask&#39;): os.makedirs(scene/&#39;binary_mask&#39;) generate_mask(img, shapes, scene/&#39;binary_mask&#39;, img.name) . . save_masks() . As mask creation failed on one image for no obvious reason. I simply deleted it from the training set. . Creating subset of dataset . Let&#39;s look at how the images in a scene change over time: . . We can see that the ~24 images of every scene are quite similar. The vegetation changes with the seasons and some scenes show building activity, but overall the similarities are greater than the differences. . Therefore I decided to ignore most images. I originally planned to keep every fifth image of every scene, so for example January, June, November, April, and September. This way we could make use of the variability of the different seasons. But it turned out that just selecting one image per scene yielded similar results with a fraction of the training time. . def get_masked_images(path:Path, n=1)-&gt;list: &quot;Returns the first `n` pictures from every scene&quot; files = [] for folder in path.ls(): files.extend(get_image_files(path=folder, folders=&#39;images_masked&#39;)[:n]) return files . . path.ls() . (#59) [Path(&#39;L15-0331E-1257N_1327_3160_13&#39;),Path(&#39;L15-0357E-1223N_1429_3296_13&#39;),Path(&#39;L15-0358E-1220N_1433_3310_13&#39;),Path(&#39;L15-0361E-1300N_1446_2989_13&#39;),Path(&#39;L15-0368E-1245N_1474_3210_13&#39;),Path(&#39;L15-0387E-1276N_1549_3087_13&#39;),Path(&#39;L15-0434E-1218N_1736_3318_13&#39;),Path(&#39;L15-0457E-1135N_1831_3648_13&#39;),Path(&#39;L15-0487E-1246N_1950_3207_13&#39;),Path(&#39;L15-0506E-1204N_2027_3374_13&#39;)...] . !ls . L15-0331E-1257N_1327_3160_13 L15-1200E-0847N_4802_4803_13 L15-0357E-1223N_1429_3296_13 L15-1203E-1203N_4815_3378_13 L15-0358E-1220N_1433_3310_13 L15-1204E-1202N_4816_3380_13 L15-0361E-1300N_1446_2989_13 L15-1204E-1204N_4819_3372_13 L15-0368E-1245N_1474_3210_13 L15-1209E-1113N_4838_3737_13 L15-0387E-1276N_1549_3087_13 L15-1210E-1025N_4840_4088_13 L15-0434E-1218N_1736_3318_13 L15-1276E-1107N_5105_3761_13 L15-0457E-1135N_1831_3648_13 L15-1289E-1169N_5156_3514_13 L15-0487E-1246N_1950_3207_13 L15-1296E-1198N_5184_3399_13 L15-0506E-1204N_2027_3374_13 L15-1298E-1322N_5193_2903_13 L15-0544E-1228N_2176_3279_13 L15-1335E-1166N_5342_3524_13 L15-0566E-1185N_2265_3451_13 L15-1389E-1284N_5557_3054_13 L15-0571E-1075N_2287_3888_13 L15-1438E-1134N_5753_3655_13 L15-0577E-1243N_2309_3217_13 L15-1439E-1134N_5759_3655_13 L15-0586E-1127N_2345_3680_13 L15-1479E-1101N_5916_3785_13 L15-0595E-1278N_2383_3079_13 L15-1481E-1119N_5927_3715_13 L15-0614E-0946N_2459_4406_13 L15-1538E-1163N_6154_3539_13 L15-0632E-0892N_2528_4620_13 L15-1615E-1205N_6460_3370_13 L15-0683E-1006N_2732_4164_13 L15-1615E-1206N_6460_3366_13 L15-0760E-0887N_3041_4643_13 L15-1617E-1207N_6468_3360_13 L15-0924E-1108N_3699_3757_13 L15-1669E-1153N_6678_3579_13 L15-0977E-1187N_3911_3441_13 L15-1669E-1160N_6678_3548_13 L15-1014E-1375N_4056_2688_13 L15-1669E-1160N_6679_3549_13 L15-1015E-1062N_4061_3941_13 L15-1672E-1207N_6691_3363_13 L15-1025E-1366N_4102_2726_13 L15-1690E-1211N_6763_3346_13 L15-1049E-1370N_4196_2710_13 L15-1691E-1211N_6764_3347_13 L15-1138E-1216N_4553_3325_13 L15-1703E-1219N_6813_3313_13 L15-1172E-1306N_4688_2967_13 L15-1709E-1112N_6838_3742_13 L15-1185E-0935N_4742_4450_13 L15-1716E-1211N_6864_3345_13 . masked_images = get_masked_images(path, 1) len(masked_images) . 58 . Dataset now consists of 58 correct full images after Datacleaning Step . Cutting images in tiles . Since the images are large (1024x1024), we cut them into 16 smaller tiles (255x255) and save them to disk. Most structures are small in relation to the whole scene, so this should not hurt training too much. Smaller tiles allow for larger batch sizes and/or deeper models to fit in GPU RAM. . Most images have 1024x1024 pixels. Some images however have only 1023 pixels in one dimension, therefore I chose 255 instead of 256 as the tile size. This throws away some pixels in most images, but maintains an equal tile size for all images. . To do: Ideally, we would create overlapping tiles to avoid some buildings being cut in half and never seen in their full shape by the model. . def cut_tiles(tile_size:int): &quot;Cuts the large images and masks into equal tiles and saves them to disk&quot; masked_images = get_masked_images(path, 5) for fn in tqdm(masked_images): scene = fn.parent.parent # Create directories if not os.path.exists(scene/&#39;img_tiles&#39;): os.makedirs(scene/&#39;img_tiles&#39;) if not os.path.exists(scene/&#39;mask_tiles&#39;): os.makedirs(scene/&#39;mask_tiles&#39;) # Create mask for current image img = np.array(PILImage.create(fn)) msk_fn = str(fn).replace(&#39;images_masked&#39;, &#39;binary_mask&#39;) msk = np.array(PILMask.create(msk_fn)) x, y, _ = img.shape # Cut tiles and save them for i in range(x//tile_size): for j in range(y//tile_size): img_tile = img[i*tile_size:(i+1)*tile_size,j*tile_size:(j+1)*tile_size] msk_tile = msk[i*tile_size:(i+1)*tile_size,j*tile_size:(j+1)*tile_size] Image.fromarray(img_tile).save(f&#39;{scene}/img_tiles/{fn.name[:-4]}_{i}_{j}.png&#39;) Image.fromarray(msk_tile).save(f&#39;{scene}/mask_tiles/{fn.name[:-4]}_{i}_{j}.png&#39;) . . . len(masked_images) #These are the images that are after the data cleaning step ready to be cut into tiles. . 58 . #del masked_images[-2] . masked_images . [Path(&#39;L15-0331E-1257N_1327_3160_13/images_masked/global_monthly_2018_01_mosaic_L15-0331E-1257N_1327_3160_13.tif&#39;), Path(&#39;L15-0357E-1223N_1429_3296_13/images_masked/global_monthly_2018_01_mosaic_L15-0357E-1223N_1429_3296_13.tif&#39;), Path(&#39;L15-0358E-1220N_1433_3310_13/images_masked/global_monthly_2018_03_mosaic_L15-0358E-1220N_1433_3310_13.tif&#39;), Path(&#39;L15-0361E-1300N_1446_2989_13/images_masked/global_monthly_2018_01_mosaic_L15-0361E-1300N_1446_2989_13.tif&#39;), Path(&#39;L15-0368E-1245N_1474_3210_13/images_masked/global_monthly_2018_01_mosaic_L15-0368E-1245N_1474_3210_13.tif&#39;), Path(&#39;L15-0387E-1276N_1549_3087_13/images_masked/global_monthly_2018_03_mosaic_L15-0387E-1276N_1549_3087_13.tif&#39;), Path(&#39;L15-0434E-1218N_1736_3318_13/images_masked/global_monthly_2018_01_mosaic_L15-0434E-1218N_1736_3318_13.tif&#39;), Path(&#39;L15-0457E-1135N_1831_3648_13/images_masked/global_monthly_2018_01_mosaic_L15-0457E-1135N_1831_3648_13.tif&#39;), Path(&#39;L15-0487E-1246N_1950_3207_13/images_masked/global_monthly_2018_02_mosaic_L15-0487E-1246N_1950_3207_13.tif&#39;), Path(&#39;L15-0506E-1204N_2027_3374_13/images_masked/global_monthly_2018_01_mosaic_L15-0506E-1204N_2027_3374_13.tif&#39;), Path(&#39;L15-0544E-1228N_2176_3279_13/images_masked/global_monthly_2018_03_mosaic_L15-0544E-1228N_2176_3279_13.tif&#39;), Path(&#39;L15-0566E-1185N_2265_3451_13/images_masked/global_monthly_2018_03_mosaic_L15-0566E-1185N_2265_3451_13.tif&#39;), Path(&#39;L15-0571E-1075N_2287_3888_13/images_masked/global_monthly_2018_03_mosaic_L15-0571E-1075N_2287_3888_13.tif&#39;), Path(&#39;L15-0577E-1243N_2309_3217_13/images_masked/global_monthly_2018_04_mosaic_L15-0577E-1243N_2309_3217_13.tif&#39;), Path(&#39;L15-0586E-1127N_2345_3680_13/images_masked/global_monthly_2018_03_mosaic_L15-0586E-1127N_2345_3680_13.tif&#39;), Path(&#39;L15-0595E-1278N_2383_3079_13/images_masked/global_monthly_2018_02_mosaic_L15-0595E-1278N_2383_3079_13.tif&#39;), Path(&#39;L15-0614E-0946N_2459_4406_13/images_masked/global_monthly_2018_05_mosaic_L15-0614E-0946N_2459_4406_13.tif&#39;), Path(&#39;L15-0632E-0892N_2528_4620_13/images_masked/global_monthly_2018_01_mosaic_L15-0632E-0892N_2528_4620_13.tif&#39;), Path(&#39;L15-0683E-1006N_2732_4164_13/images_masked/global_monthly_2018_02_mosaic_L15-0683E-1006N_2732_4164_13.tif&#39;), Path(&#39;L15-0760E-0887N_3041_4643_13/images_masked/global_monthly_2018_02_mosaic_L15-0760E-0887N_3041_4643_13.tif&#39;), Path(&#39;L15-0924E-1108N_3699_3757_13/images_masked/global_monthly_2018_01_mosaic_L15-0924E-1108N_3699_3757_13.tif&#39;), Path(&#39;L15-0977E-1187N_3911_3441_13/images_masked/global_monthly_2018_04_mosaic_L15-0977E-1187N_3911_3441_13.tif&#39;), Path(&#39;L15-1014E-1375N_4056_2688_13/images_masked/global_monthly_2018_03_mosaic_L15-1014E-1375N_4056_2688_13.tif&#39;), Path(&#39;L15-1015E-1062N_4061_3941_13/images_masked/global_monthly_2018_02_mosaic_L15-1015E-1062N_4061_3941_13.tif&#39;), Path(&#39;L15-1025E-1366N_4102_2726_13/images_masked/global_monthly_2018_01_mosaic_L15-1025E-1366N_4102_2726_13.tif&#39;), Path(&#39;L15-1049E-1370N_4196_2710_13/images_masked/global_monthly_2018_01_mosaic_L15-1049E-1370N_4196_2710_13.tif&#39;), Path(&#39;L15-1138E-1216N_4553_3325_13/images_masked/global_monthly_2018_02_mosaic_L15-1138E-1216N_4553_3325_13.tif&#39;), Path(&#39;L15-1172E-1306N_4688_2967_13/images_masked/global_monthly_2018_01_mosaic_L15-1172E-1306N_4688_2967_13.tif&#39;), Path(&#39;L15-1185E-0935N_4742_4450_13/images_masked/global_monthly_2018_04_mosaic_L15-1185E-0935N_4742_4450_13.tif&#39;), Path(&#39;L15-1200E-0847N_4802_4803_13/images_masked/global_monthly_2018_02_mosaic_L15-1200E-0847N_4802_4803_13.tif&#39;), Path(&#39;L15-1203E-1203N_4815_3378_13/images_masked/global_monthly_2018_02_mosaic_L15-1203E-1203N_4815_3378_13.tif&#39;), Path(&#39;L15-1204E-1202N_4816_3380_13/images_masked/global_monthly_2017_08_mosaic_L15-1204E-1202N_4816_3380_13.tif&#39;), Path(&#39;L15-1204E-1204N_4819_3372_13/images_masked/global_monthly_2018_01_mosaic_L15-1204E-1204N_4819_3372_13.tif&#39;), Path(&#39;L15-1209E-1113N_4838_3737_13/images_masked/global_monthly_2018_01_mosaic_L15-1209E-1113N_4838_3737_13.tif&#39;), Path(&#39;L15-1210E-1025N_4840_4088_13/images_masked/global_monthly_2018_01_mosaic_L15-1210E-1025N_4840_4088_13.tif&#39;), Path(&#39;L15-1276E-1107N_5105_3761_13/images_masked/global_monthly_2018_01_mosaic_L15-1276E-1107N_5105_3761_13.tif&#39;), Path(&#39;L15-1289E-1169N_5156_3514_13/images_masked/global_monthly_2018_03_mosaic_L15-1289E-1169N_5156_3514_13.tif&#39;), Path(&#39;L15-1296E-1198N_5184_3399_13/images_masked/global_monthly_2018_02_mosaic_L15-1296E-1198N_5184_3399_13.tif&#39;), Path(&#39;L15-1298E-1322N_5193_2903_13/images_masked/global_monthly_2018_01_mosaic_L15-1298E-1322N_5193_2903_13.tif&#39;), Path(&#39;L15-1335E-1166N_5342_3524_13/images_masked/global_monthly_2018_01_mosaic_L15-1335E-1166N_5342_3524_13.tif&#39;), Path(&#39;L15-1389E-1284N_5557_3054_13/images_masked/global_monthly_2018_02_mosaic_L15-1389E-1284N_5557_3054_13.tif&#39;), Path(&#39;L15-1438E-1134N_5753_3655_13/images_masked/global_monthly_2018_03_mosaic_L15-1438E-1134N_5753_3655_13.tif&#39;), Path(&#39;L15-1439E-1134N_5759_3655_13/images_masked/global_monthly_2018_02_mosaic_L15-1439E-1134N_5759_3655_13.tif&#39;), Path(&#39;L15-1479E-1101N_5916_3785_13/images_masked/global_monthly_2018_03_mosaic_L15-1479E-1101N_5916_3785_13.tif&#39;), Path(&#39;L15-1481E-1119N_5927_3715_13/images_masked/global_monthly_2018_01_mosaic_L15-1481E-1119N_5927_3715_13.tif&#39;), Path(&#39;L15-1538E-1163N_6154_3539_13/images_masked/global_monthly_2018_01_mosaic_L15-1538E-1163N_6154_3539_13.tif&#39;), Path(&#39;L15-1615E-1205N_6460_3370_13/images_masked/global_monthly_2017_07_mosaic_L15-1615E-1205N_6460_3370_13.tif&#39;), Path(&#39;L15-1615E-1206N_6460_3366_13/images_masked/global_monthly_2017_10_mosaic_L15-1615E-1206N_6460_3366_13.tif&#39;), Path(&#39;L15-1617E-1207N_6468_3360_13/images_masked/global_monthly_2018_02_mosaic_L15-1617E-1207N_6468_3360_13.tif&#39;), Path(&#39;L15-1669E-1153N_6678_3579_13/images_masked/global_monthly_2018_01_mosaic_L15-1669E-1153N_6678_3579_13.tif&#39;), Path(&#39;L15-1669E-1160N_6678_3548_13/images_masked/global_monthly_2017_10_mosaic_L15-1669E-1160N_6678_3548_13.tif&#39;), Path(&#39;L15-1669E-1160N_6679_3549_13/images_masked/global_monthly_2017_10_mosaic_L15-1669E-1160N_6679_3549_13.tif&#39;), Path(&#39;L15-1672E-1207N_6691_3363_13/images_masked/global_monthly_2018_02_mosaic_L15-1672E-1207N_6691_3363_13.tif&#39;), Path(&#39;L15-1690E-1211N_6763_3346_13/images_masked/global_monthly_2017_08_mosaic_L15-1690E-1211N_6763_3346_13.tif&#39;), Path(&#39;L15-1691E-1211N_6764_3347_13/images_masked/global_monthly_2018_02_mosaic_L15-1691E-1211N_6764_3347_13.tif&#39;), Path(&#39;L15-1703E-1219N_6813_3313_13/images_masked/global_monthly_2018_01_mosaic_L15-1703E-1219N_6813_3313_13.tif&#39;), Path(&#39;L15-1709E-1112N_6838_3742_13/images_masked/global_monthly_2018_01_mosaic_L15-1709E-1112N_6838_3742_13.tif&#39;), Path(&#39;L15-1716E-1211N_6864_3345_13/images_masked/global_monthly_2018_02_mosaic_L15-1716E-1211N_6864_3345_13.tif&#39;)] . path.ls() . (#59) [Path(&#39;L15-0331E-1257N_1327_3160_13&#39;),Path(&#39;L15-0357E-1223N_1429_3296_13&#39;),Path(&#39;L15-0358E-1220N_1433_3310_13&#39;),Path(&#39;L15-0361E-1300N_1446_2989_13&#39;),Path(&#39;L15-0368E-1245N_1474_3210_13&#39;),Path(&#39;L15-0387E-1276N_1549_3087_13&#39;),Path(&#39;L15-0434E-1218N_1736_3318_13&#39;),Path(&#39;L15-0457E-1135N_1831_3648_13&#39;),Path(&#39;L15-0487E-1246N_1950_3207_13&#39;),Path(&#39;L15-0506E-1204N_2027_3374_13&#39;)...] . path.ls() . (#59) [Path(&#39;L15-0331E-1257N_1327_3160_13&#39;),Path(&#39;L15-0357E-1223N_1429_3296_13&#39;),Path(&#39;L15-0358E-1220N_1433_3310_13&#39;),Path(&#39;L15-0361E-1300N_1446_2989_13&#39;),Path(&#39;L15-0368E-1245N_1474_3210_13&#39;),Path(&#39;L15-0387E-1276N_1549_3087_13&#39;),Path(&#39;L15-0434E-1218N_1736_3318_13&#39;),Path(&#39;L15-0457E-1135N_1831_3648_13&#39;),Path(&#39;L15-0487E-1246N_1950_3207_13&#39;),Path(&#39;L15-0506E-1204N_2027_3374_13&#39;)...] . Data Loading Functions . Little helper functions . def get_image_tiles(path:Path, n_tiles=TILES_PER_SCENE) -&gt; L: &quot;Returns a list of the first `n` image tile filenames in `path`&quot; files = L() for folder in path.ls(): files.extend(get_image_files(path=folder, folders=&#39;img_tiles&#39;)[:n_tiles]) return files . def get_y_fn(fn:Path) -&gt; str: &quot;Returns filename of the associated mask tile for a given image tile&quot; return str(fn).replace(&#39;img_tiles&#39;, &#39;mask_tiles&#39;) . def get_y(fn:Path) -&gt; PILMask: &quot;Returns a PILMask object of 0s and 1s for a given tile&quot; fn = get_y_fn(fn) msk = np.array(PILMask.create(fn)) msk[msk==255] = 1 return PILMask.create(msk) . Visualizing Data . Let&#39;s look at some raw image tiles and their masks. . def show_tiles(n): all_tiles = get_image_tiles(path) subset = random.sample(all_tiles, n) fig, ax = plt.subplots(n//2, 4, figsize=(14,14)) for i in range(n): y = i//2 x = 2*i%4 PILImage.create(subset[i]).show(ctx=ax[y, x]) get_y(subset[i]).show(ctx=ax[y, x+1], cmap=&#39;cividis&#39;) fig.tight_layout() plt.show() . . show_tiles(8) . Challenges of the dataset . As we can see in the visualizations, the dataset provides some challenges: . The buildings are often extremely small, just a few pixels, and very close to each other | On the other hand, there are large structures that cover a much greater area than small buildings | Some buildings are hard to recognize, even for the human eye | The density of buildings varies greatly. There are tiles with no buildings at all, other tiles show urban scenes with hundreds of buildings | The images are very diverse, with great differences in topography, vegetation and urbanization | Some tiles are covered partially or completely with UDM masks | . Distribution of building density . To explore how imbalanced the data is exactly, we&#39;ll analyze the percentages of building pixels in each tile. We create a simple dataloader to easily load and analyze the masks. . tiles = DataBlock( blocks = (ImageBlock(),MaskBlock(codes=CODES)), get_items = get_image_tiles, get_y = get_y ) dls = tiles.dataloaders(path, bs=BATCH_SIZE) dls.vocab = CODES . . targs = torch.zeros((0,255,255)) for _, masks in dls[0]: targs = torch.cat((targs, masks.cpu()), dim=0) targs.shape . torch.Size([732, 255, 255]) . We have 732 image tiles in total. . Calculating the percentage of building pixels vs background pixels: . total_pixels = targs.shape[1]**2 percentages = torch.count_nonzero(targs, dim=(1,2))/total_pixels plt.hist(percentages, bins=20) plt.ylabel(&#39;Number of tiles&#39;) plt.xlabel(&#39;Ratio of pixels that are of class `building`&#39;) plt.gca().spines[&#39;top&#39;].set_color(&#39;none&#39;) plt.gca().spines[&#39;right&#39;].set_color(&#39;none&#39;) plt.show() . . We can see that many tiles contain no or very few buildings. . torch.count_nonzero((percentages==0.).float()).item() . 64 . 64 images do not contain a single pixel of the building class, that&#39;s almost 10% of the images. These can be areas of empty land, water, or tiles that were covered in clouds. . What is the tile with the largest percentage of buildings? . targs[percentages.argsort(descending=True)[0]].show(); . What is the overall ratio building/background? . print(percentages.mean().item(), percentages.median().item()) . 0.06513693183660507 0.036139946430921555 . On average, 6.5% of a tile&#39;s pixels are of the building class. The median is only 3.6%. This means this is a rather imbalanced dataset. . Validation Strategy . To allow the evaluation of the performance of our model, we set aside 15% of the dataset as validation set. . We must be thoughtful about how we create this validation set. Using random images would be too easy, as we have several images per scene that differ only slightly. Our validation set would not be thoroughly separated from the training set. . Instead, I chose to randomly select 9 scenes that are used as validation data. The model will never see any images from these scenes during training. . VALID_SCENES = [&#39;L15-0571E-1075N_2287_3888_13&#39;, &#39;L15-1615E-1205N_6460_3370_13&#39;, &#39;L15-1210E-1025N_4840_4088_13&#39;, &#39;L15-1185E-0935N_4742_4450_13&#39;, &#39;L15-1481E-1119N_5927_3715_13&#39;, &#39;L15-0632E-0892N_2528_4620_13&#39;, &#39;L15-1438E-1134N_5753_3655_13&#39;, &#39;L15-0924E-1108N_3699_3757_13&#39;, &#39;L15-0457E-1135N_1831_3648_13&#39;] . def valid_split(item): scene = item.parent.parent.name return scene in VALID_SCENES . Undersampling . To help mitigating the imbalanced classes, we remove all tiles that contain no buildings at all from the training set. This reduces the amount of samples by ~10%, thereby accelerating the training while helping the model perform better. . def has_buildings(fn:Path) -&gt; bool: &quot;&quot;&quot;Returns whether the mask of a given image tile contains at least one pixel of a building&quot;&quot;&quot; fn = get_y_fn(fn) msk = tensor(PILMask.create(fn)) count = torch.count_nonzero(msk) return count&gt;0. . . def get_undersampled_tiles(path:Path) -&gt; L: &quot;&quot;&quot;Returns a list of image tile filenames in `path`. For tiles in the training set, empty tiles are ignored. All tiles in the validation set are included.&quot;&quot;&quot; files = get_image_tiles(path) train_idxs, valid_idxs = FuncSplitter(valid_split)(files) train_files = L(filter(has_buildings, files[train_idxs])) valid_files = files[valid_idxs] return train_files + valid_files . . Creating Dataloaders . The following transformations seem reasonable for satellite images. We flip the tiles vertically and horizontally, rotate them, change brightness, contrast and saturation by a small amount. We normalize them according to ImageNet stats, so that we can use a pretrained model later. . tfms = [Dihedral(0.5), # Horizontal and vertical flip Rotate(max_deg=180, p=0.9), # Rotation in any direction possible Brightness(0.2, p=0.75), Contrast(0.2), Saturation(0.2), Normalize.from_stats(*imagenet_stats)] . To create the datasets, we use the convenient DataBlock API of fastai. We only load 16 tiles per scene, so only 1 image per region. . tiles = DataBlock( blocks = (ImageBlock(),MaskBlock(codes=CODES)), # Independent variable is Image, dependent variable is Mask get_items = get_undersampled_tiles, # Collect undersampled tiles get_y = get_y, # Get dependent variable: mask splitter = FuncSplitter(valid_split), # Split into training and validation set batch_tfms = tfms # Transforms on GPU: augmentation, normalization ) . dls = tiles.dataloaders(path, bs=BATCH_SIZE) dls.vocab = CODES . len(dls.train_ds), len(dls.valid_ds) . (715, 144) . We have 715 correct tiles in the training set and 144 tiles in the validation set. . Making sure the batches look okay: . inputs, targets = dls.one_batch() . inputs.shape, targets.shape . (torch.Size([12, 3, 255, 255]), torch.Size([12, 255, 255])) . These dimensions are as expected: . 12 images per batch | 3 channels for the input images | no color channels for the target mask | image size: 255x255. | . Check that the mask looks as expected, 0s and 1s: . targets[0].unique() . TensorMask([0, 1], device=&#39;cuda:0&#39;) . Defining the Model . The task at hand is an image segmentation problem. In the original competition, it is required to assign individual labels to each building to keep track of it over time (instance segmentation). Here, I chose to do semantic segmentation instead, so just classifying for every pixel if it belongs to a building or not. . The fastai library allows the remarkably simple creation of a U-Net, a standard architecture for image segmentation problems. The module DynamicUNet - provided with an encoder architecture - automatically constructs a decoder and cross connections. This makes it easy to build a U-Net out of different (and pretrained) architectures. I chose this approach to have more time to experiment instead of writing code from scratch. I considered following aspects: . Encoder: I picked a xResNet34 model that has been pretrained on ImageNet. A 34-layer encoder seems like a good compromise between accuracy and memory/compute requirements. | Loss function: The choice of the loss function is important for segmentation problems. I&#39;ll use a weighted pixel-wise cross-entropy loss. The weights are important for the imbalanced dataset. | Optimizer: I use the default optimizer, Adam. | Metrics: As the classes are very imbalanced, a simple accuracy metric would not be helpful. In a picture with 3% buildings, the model could predict &quot;no building&quot; on every pixel and still get 97% accuracy. | Instead, I focus on the Dice metric, it is often used for segmentation tasks. It is equivalent to the F1 score and measures the ratio of $ frac{2TP}{2TP + FP + FN}$ | Additionally, I added foreground_acc of fastai, it measures the percentage of foreground pixels correctly classified, the Recall. Foreground in this case is the building class. | . | . weights = Tensor(CLASS_WEIGHTS).cuda() loss_func = CrossEntropyLossFlat(axis=1, weight=weights) . With some experimentation, the class weights 0.25 for the background and 0.75 for the building class seem to work fine. . learn = unet_learner(dls, # DataLoaders ARCHITECTURE, # xResNet34 loss_func = loss_func, # Weighted cross entropy loss opt_func = Adam, # Adam optimizer metrics = [Dice(), foreground_acc], # Custom metrics self_attention = False, cbs = [SaveModelCallback( monitor=&#39;dice&#39;, comp=np.greater, fname=&#39;best-model-34&#39; )] ) . Summary of the model: . learn.summary() . DynamicUnet (Input shape: 12) ============================================================================ Layer (type) Output Shape Param # Trainable ============================================================================ 12 x 32 x 128 x 128 Conv2d 864 False BatchNorm2d 64 True ReLU Conv2d 9216 False BatchNorm2d 64 True ReLU ____________________________________________________________________________ 12 x 64 x 128 x 128 Conv2d 18432 False BatchNorm2d 128 True ReLU MaxPool2d Conv2d 36864 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True Sequential ReLU Conv2d 36864 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True Sequential ReLU Conv2d 36864 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True Sequential ReLU ____________________________________________________________________________ 12 x 128 x 32 x 32 Conv2d 73728 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 128 x 32 x 32 Conv2d 8192 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True Sequential ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True Sequential ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True Sequential ReLU ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 294912 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 32768 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 1179648 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 131072 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True Sequential ReLU Conv2d 2359296 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True Sequential ReLU BatchNorm2d 1024 True ReLU ____________________________________________________________________________ 12 x 1024 x 8 x 8 Conv2d 4719616 True ReLU ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 4719104 True ReLU ____________________________________________________________________________ 12 x 1024 x 8 x 8 Conv2d 525312 True ReLU PixelShuffle BatchNorm2d 512 True Conv2d 2359808 True ReLU Conv2d 2359808 True ReLU ReLU ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 525312 True ReLU PixelShuffle BatchNorm2d 256 True Conv2d 1327488 True ReLU Conv2d 1327488 True ReLU ReLU ____________________________________________________________________________ 12 x 768 x 32 x 32 Conv2d 295680 True ReLU PixelShuffle BatchNorm2d 128 True Conv2d 590080 True ReLU Conv2d 590080 True ReLU ReLU ____________________________________________________________________________ 12 x 512 x 64 x 64 Conv2d 131584 True ReLU PixelShuffle BatchNorm2d 128 True ____________________________________________________________________________ 12 x 96 x 128 x 128 Conv2d 165984 True ReLU Conv2d 83040 True ReLU ReLU ____________________________________________________________________________ 12 x 384 x 128 x 12 Conv2d 37248 True ReLU PixelShuffle ResizeToOrig MergeLayer Conv2d 88308 True ReLU Conv2d 88308 True Sequential ReLU ____________________________________________________________________________ 12 x 2 x 255 x 255 Conv2d 200 True ToTensorBase ____________________________________________________________________________ Total params: 41,240,400 Total trainable params: 19,953,648 Total non-trainable params: 21,286,752 Optimizer used: &lt;function Adam at 0x7fea8c0c5200&gt; Loss function: FlattenedLoss of CrossEntropyLoss() Model frozen up to parameter group #2 Callbacks: - TrainEvalCallback - Recorder - ProgressCallback - SaveModelCallback . . This is the full UNet model: . learn.model . DynamicUnet( (layers): ModuleList( (0): Sequential( (0): ConvLayer( (0): Conv2d(3, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (3): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (4): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (5): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (3): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (6): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (3): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (4): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (5): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (7): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) ) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() (3): Sequential( (0): ConvLayer( (0): Conv2d(512, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (1): ConvLayer( (0): Conv2d(1024, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) ) (4): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (5): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(384, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(384, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (6): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(384, 768, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (7): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(192, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(96, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (8): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(96, 384, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (9): ResizeToOrig() (10): MergeLayer() (11): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(99, 99, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (1): ConvLayer( (0): Conv2d(99, 99, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (12): ConvLayer( (0): Conv2d(99, 2, kernel_size=(1, 1), stride=(1, 1)) ) (13): ToTensorBase(tensor_cls=&lt;class &#39;fastai.torch_core.TensorBase&#39;&gt;) ) ) . . Training . We can use fastai&#39;s learning rate finder to pick a reasonable learning rate: . learn.lr_find(suggestions=False)) . SuggestedLRs(valley=tensor(6.3096e-05)) . Somewhere around 1e-4 seems reasonable, where the loss decreases steadily. . lr_max = LR_MAX # 3e-4 . We unfreeze the model to train the encoder and decoder simultaneously. The encoder should be trained at a lower learning rate, since we don&#39;t want to change the pretrained features too much. This is achieved by setting the learning rate to slice(lr_max/10, lr_max) . We use the fit_one_cycle method, where the learning rate starts low for a warm up period, reaches a maximum of lr_max and then anneals to 0 at the end of training. . !nvidia-smi . Tue Jul 6 07:59:28 2021 +--+ | NVIDIA-SMI 465.27 Driver Version: 460.32.03 CUDA Version: 11.2 | |-+-+-+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla T4 Off | 00000000:00:04.0 Off | 0 | | N/A 60C P0 29W / 70W | 8166MiB / 15109MiB | 0% Default | | | | N/A | +-+-+-+ +--+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| +--+ . ls . L15-0331E-1257N_1327_3160_13/ L15-1203E-1203N_4815_3378_13/ L15-0357E-1223N_1429_3296_13/ L15-1204E-1202N_4816_3380_13/ L15-0358E-1220N_1433_3310_13/ L15-1204E-1204N_4819_3372_13/ L15-0361E-1300N_1446_2989_13/ L15-1209E-1113N_4838_3737_13/ L15-0368E-1245N_1474_3210_13/ L15-1210E-1025N_4840_4088_13/ L15-0387E-1276N_1549_3087_13/ L15-1276E-1107N_5105_3761_13/ L15-0434E-1218N_1736_3318_13/ L15-1289E-1169N_5156_3514_13/ L15-0457E-1135N_1831_3648_13/ L15-1296E-1198N_5184_3399_13/ L15-0487E-1246N_1950_3207_13/ L15-1298E-1322N_5193_2903_13/ L15-0506E-1204N_2027_3374_13/ L15-1335E-1166N_5342_3524_13/ L15-0544E-1228N_2176_3279_13/ L15-1389E-1284N_5557_3054_13/ L15-0566E-1185N_2265_3451_13/ L15-1438E-1134N_5753_3655_13/ L15-0571E-1075N_2287_3888_13/ L15-1439E-1134N_5759_3655_13/ L15-0577E-1243N_2309_3217_13/ L15-1479E-1101N_5916_3785_13/ L15-0586E-1127N_2345_3680_13/ L15-1481E-1119N_5927_3715_13/ L15-0595E-1278N_2383_3079_13/ L15-1538E-1163N_6154_3539_13/ L15-0614E-0946N_2459_4406_13/ L15-1615E-1205N_6460_3370_13/ L15-0632E-0892N_2528_4620_13/ L15-1615E-1206N_6460_3366_13/ L15-0683E-1006N_2732_4164_13/ L15-1617E-1207N_6468_3360_13/ L15-0760E-0887N_3041_4643_13/ L15-1669E-1153N_6678_3579_13/ L15-0924E-1108N_3699_3757_13/ L15-1669E-1160N_6678_3548_13/ L15-0977E-1187N_3911_3441_13/ L15-1669E-1160N_6679_3549_13/ L15-1014E-1375N_4056_2688_13/ L15-1672E-1207N_6691_3363_13/ L15-1015E-1062N_4061_3941_13/ L15-1690E-1211N_6763_3346_13/ L15-1025E-1366N_4102_2726_13/ L15-1691E-1211N_6764_3347_13/ L15-1049E-1370N_4196_2710_13/ L15-1703E-1219N_6813_3313_13/ L15-1138E-1216N_4553_3325_13/ L15-1709E-1112N_6838_3742_13/ L15-1172E-1306N_4688_2967_13/ L15-1716E-1211N_6864_3345_13/ L15-1185E-0935N_4742_4450_13/ models/ L15-1200E-0847N_4802_4803_13/ . !ls . gdrive sample_data . --Experiment Run: 1 . #collapse-output learn.unfreeze() learn.fit_one_cycle( EPOCHS, lr_max=slice(lr_max/ENCODER_FACTOR, lr_max), cbs=[WandbCallback()] ) . epoch train_loss valid_loss dice foreground_acc time . 0 | 0.388443 | 0.413384 | 0.289366 | 0.174573 | 00:50 | . 1 | 0.349046 | 0.359303 | 0.461197 | 0.445781 | 00:44 | . 2 | 0.332909 | 0.349615 | 0.490519 | 0.481620 | 00:45 | . 3 | 0.328296 | 0.404246 | 0.307558 | 0.176636 | 00:44 | . 4 | 0.311649 | 0.331803 | 0.518899 | 0.552372 | 00:44 | . 5 | 0.315864 | 0.333278 | 0.496052 | 0.437288 | 00:45 | . 6 | 0.305936 | 0.369581 | 0.500008 | 0.671848 | 00:45 | . 7 | 0.306035 | 0.335628 | 0.522586 | 0.520908 | 00:45 | . 8 | 0.295921 | 0.330779 | 0.530826 | 0.513260 | 00:46 | . 9 | 0.290359 | 0.311421 | 0.545738 | 0.579524 | 00:46 | . 10 | 0.294897 | 0.325334 | 0.530101 | 0.488870 | 00:46 | . 11 | 0.286177 | 0.327654 | 0.539763 | 0.652674 | 00:46 | . 12 | 0.278001 | 0.354929 | 0.485753 | 0.677047 | 00:46 | . 13 | 0.275921 | 0.346134 | 0.534323 | 0.538300 | 00:46 | . 14 | 0.271893 | 0.336453 | 0.529238 | 0.586955 | 00:46 | . 15 | 0.270011 | 0.351094 | 0.522521 | 0.472264 | 00:46 | . 16 | 0.266521 | 0.455999 | 0.513976 | 0.443002 | 00:46 | . 17 | 0.260103 | 0.323886 | 0.543388 | 0.594548 | 00:46 | . 18 | 0.259548 | 0.317344 | 0.557026 | 0.604788 | 00:46 | . 19 | 0.252726 | 0.342917 | 0.537662 | 0.612756 | 00:46 | . 20 | 0.248773 | 0.313652 | 0.553115 | 0.602638 | 00:46 | . 21 | 0.244121 | 0.335954 | 0.549108 | 0.563031 | 00:46 | . 22 | 0.246857 | 0.315527 | 0.554965 | 0.656071 | 00:46 | . 23 | 0.246583 | 0.309595 | 0.560354 | 0.621056 | 00:46 | . 24 | 0.246868 | 0.322774 | 0.548355 | 0.565873 | 00:46 | . 25 | 0.243858 | 0.314193 | 0.549589 | 0.677579 | 00:46 | . 26 | 0.238657 | 0.318479 | 0.553847 | 0.552282 | 00:46 | . 27 | 0.236678 | 0.319910 | 0.553423 | 0.588908 | 00:46 | . 28 | 0.234124 | 0.306141 | 0.552694 | 0.669329 | 00:46 | . 29 | 0.230853 | 0.328426 | 0.550115 | 0.606573 | 00:46 | . 30 | 0.232298 | 0.314922 | 0.556050 | 0.686611 | 00:46 | . 31 | 0.230854 | 0.324863 | 0.551161 | 0.623305 | 00:46 | . 32 | 0.231132 | 0.321707 | 0.548863 | 0.629805 | 00:46 | . 33 | 0.231481 | 0.318916 | 0.552225 | 0.637253 | 00:46 | . 34 | 0.225996 | 0.320821 | 0.552282 | 0.626153 | 00:46 | . 35 | 0.220080 | 0.326714 | 0.551576 | 0.615147 | 00:46 | . 36 | 0.225850 | 0.327396 | 0.551351 | 0.619062 | 00:47 | . 37 | 0.227767 | 0.326052 | 0.552426 | 0.623551 | 00:46 | . 38 | 0.221003 | 0.317112 | 0.554034 | 0.647620 | 00:46 | . 39 | 0.220426 | 0.318014 | 0.554319 | 0.637630 | 00:46 | . Better model found at epoch 0 with dice value: 0.289366090884329. Better model found at epoch 1 with dice value: 0.4611968357497782. Better model found at epoch 2 with dice value: 0.4905194190974164. Better model found at epoch 4 with dice value: 0.518899214365881. Better model found at epoch 7 with dice value: 0.5225864940854509. Better model found at epoch 8 with dice value: 0.5308255345561974. Better model found at epoch 9 with dice value: 0.5457375700715181. Better model found at epoch 18 with dice value: 0.557025656659146. Better model found at epoch 23 with dice value: 0.5603543324449821. . . learn.recorder.plot_loss() . learn.save(&#39;best-model-34&#39;) . Path(&#39;models/best-model-34.pth&#39;) . The best model at epoch 23 has a Dice score of 0.56. The theoretic maximum - a perfect segmentation - is 1.0. . learn.recorder.plot_loss() . run.finish() . Waiting for W&amp;B process to finish, PID 6232Program ended successfully. Find user logs for this run at: /content/gdrive/Shareddrives/Undrive/s7/SN7_buildings_train/train/wandb/run-20210706_090514-3cwyiul0/logs/debug.log Find internal logs for this run at: /content/gdrive/Shareddrives/Undrive/s7/SN7_buildings_train/train/wandb/run-20210706_090514-3cwyiul0/logs/debug-internal.log Synced 4 W&amp;B file(s), 0 media file(s), 0 artifact file(s) and 0 other file(s) Synced laced-glade-14: https://wandb.ai/priyank7n/s7/runs/3cwyiul0 Visualizing the Results . . Note: The following results actually come from the model of a different training run, also with a Dice score of 0.57 Let&#39;s get all predictions on the validation set and have a look at them. . probs,targets,preds,losses = learn.get_preds(dl=dls.valid, with_loss=True, with_decoded=True, act=None) . Sort descending by loss: . loss_sorted = torch.argsort(losses, descending=True) n = len(loss_sorted) . Helper function to show predictions: . def show_single_pred(index:int): fig, ax = plt.subplots(1, 4, figsize=(20,5)) dls.valid_ds[index][0].show(ctx=ax[0]); ax[0].set_title(&quot;Input&quot;) show_at(dls.valid_ds, index, cmap=&#39;Blues&#39;, ctx=ax[1]); ax[1].set_title(&quot;Target&quot;) preds[index].show(cmap=&#39;Blues&#39;, ctx=ax[2]); ax[2].set_title(&quot;Prediction Mask&quot;) probs[index][1].show(cmap=&#39;viridis&#39;, ctx=ax[3]); ax[3].set_title(&quot;Building class probability&quot;) . . Plot the samples with the highest losses . for idx in loss_sorted[:3]: print(f&#39;Tile #{idx}, loss: {losses[idx]}&#39;) show_single_pred(idx) . . Tile #110, loss: 0.7653330564498901 Tile #101, loss: 0.541749119758606 Tile #111, loss: 0.4768364429473877 . All images with the highest losses show dense urban areas. What&#39;s noticable is the trouble that the model has with large buildings, which are often completely overlooked. It&#39;s also clear that very small buildings are merged into &quot;blobs&quot;. I suspect tracking individual buildings could be difficult here. . Plot samples with medium losses . for idx in loss_sorted[n//2-1:n//2+2]: print(f&#39;Tile #{idx}, loss: {losses[idx]}&#39;) show_single_pred(idx) . . Tile #1, loss: 0.06586822122335434 Tile #7, loss: 0.06451009213924408 Tile #55, loss: 0.0639784187078476 . The model tends to merge small buildings into larger blobs, and there are several false positives. But there are also some quite good predictions, picking up buildings that are hard even for the human eye to pick up. . Plot some examples with low losses . for idx in loss_sorted[-21:-18]: print(f&#39;Tile #{idx}, loss: {losses[idx]}&#39;) show_single_pred(idx) . . Tile #51, loss: 0.0051777600310742855 Tile #92, loss: 0.005046222358942032 Tile #9, loss: 0.004601902794092894 . The model shows mixed performance in images with few buildings in them. Overall, the accuracy looks better here than in dense areas. But the model tends to produce false positives; and some tiles show weird artifacts in the corners. It seems as if the model interprets the corners itself as buildings, especially on tiles covered with water. . Show complete scenes . Predict all tiles of a scene: . path.ls() . (#60) [Path(&#39;L15-0760E-0887N_3041_4643_13&#39;),Path(&#39;L15-0683E-1006N_2732_4164_13&#39;),Path(&#39;L15-0632E-0892N_2528_4620_13&#39;),Path(&#39;L15-0614E-0946N_2459_4406_13&#39;),Path(&#39;L15-0595E-1278N_2383_3079_13&#39;),Path(&#39;L15-0586E-1127N_2345_3680_13&#39;),Path(&#39;L15-0977E-1187N_3911_3441_13&#39;),Path(&#39;L15-0924E-1108N_3699_3757_13&#39;),Path(&#39;L15-1014E-1375N_4056_2688_13&#39;),Path(&#39;L15-1025E-1366N_4102_2726_13&#39;)...] . def save_predictions(scene, path=path) -&gt; None: &quot;Predicts all 16 tiles of one scene and saves them to disk&quot; output_folder = path/scene/&#39;predicted_tiles&#39; if not os.path.exists(output_folder): os.makedirs(output_folder) tiles = get_image_files(path/scene/&#39;img_tiles&#39;).sorted() for i in range(16): tile_preds = learn.predict(tiles[i]) to_image(tile_preds[2][1].repeat(3,1,1)).save(output_folder/f&#39;{i:02d}.png&#39;) . . VALID_SCENES . [&#39;L15-0571E-1075N_2287_3888_13&#39;, &#39;L15-1615E-1205N_6460_3370_13&#39;, &#39;L15-1210E-1025N_4840_4088_13&#39;, &#39;L15-1185E-0935N_4742_4450_13&#39;, &#39;L15-1481E-1119N_5927_3715_13&#39;, &#39;L15-0632E-0892N_2528_4620_13&#39;, &#39;L15-1438E-1134N_5753_3655_13&#39;, &#39;L15-0924E-1108N_3699_3757_13&#39;, &#39;L15-0457E-1135N_1831_3648_13&#39;] . scene = VALID_SCENES[0] # &#39;L15-0571E-1075N_2287_3888_13&#39; . scene = VALID_SCENES[0:] # &#39; . scene . &#39;L15-1210E-1025N_4840_4088_13&#39; . save_predictions(scene) . Helper function to show several tiles as a large image: . def unblockshaped(arr, h, w): &quot;&quot;&quot; Return an array of shape (h, w) where h * w = arr.size If arr is of shape (n, nrows, ncols), n sublocks of shape (nrows, ncols), then the returned array preserves the &quot;physical&quot; layout of the sublocks. Source: https://stackoverflow.com/a/16873755 &quot;&quot;&quot; try: # with color channel n, nrows, ncols, c = arr.shape return (arr.reshape(h//nrows, -1, nrows, ncols, c) .swapaxes(1,2) .reshape(h, w, c)) except ValueError: # without color channel n, nrows, ncols = arr.shape return (arr.reshape(h//nrows, -1, nrows, ncols) .swapaxes(1,2) .reshape(h, w)) . . Load saved predictions: . def get_saved_preds(scene, path=path): &quot;Load saved prediction mask tiles for a scene and return image + assembled mask&quot; image_file = (path/scene/&#39;images_masked&#39;).ls()[0] image = load_image(image_file) mask_tiles = get_image_files(path/scene/&#39;predicted_tiles&#39;).sorted() mask_arrs = np.array(list(maps(partial(load_image, mode=&quot;L&quot;), np.asarray, mask_tiles))) mask_array = unblockshaped(np.array(mask_arrs), 1020, 1020) return (image, mask_array) . . Show image + stitched predictions: . def show_complete_preds(image, mask_array, scene): &quot;Source: https://github.com/CosmiQ/CosmiQ_SN7_Baseline/blob/master/notebooks/sn7_baseline.ipynb&quot; figsize = (25, 16) fig, (ax0, ax1) = plt.subplots(1, 2, figsize=figsize) _ = ax0.imshow(image) ax0.set_xticks([]) ax0.set_yticks([]) ax0.set_title(&#39;Image&#39;) _ = ax1.imshow(mask_array, cmap=&#39;viridis&#39;) ax1.set_xticks([]) ax1.set_yticks([]) ax1.set_title(&#39;Prediction Mask&#39;) plt.suptitle(scene) plt.tight_layout() plt.savefig(os.path.join(path, scene + &#39;_im0+mask0+dice575.png&#39;)) plt.show() . . show_complete_preds(*get_saved_preds(scene), scene) . VALID_SCENES . [&#39;L15-0571E-1075N_2287_3888_13&#39;, &#39;L15-1615E-1205N_6460_3370_13&#39;, &#39;L15-1210E-1025N_4840_4088_13&#39;, &#39;L15-1185E-0935N_4742_4450_13&#39;, &#39;L15-1481E-1119N_5927_3715_13&#39;, &#39;L15-0632E-0892N_2528_4620_13&#39;, &#39;L15-1438E-1134N_5753_3655_13&#39;, &#39;L15-0924E-1108N_3699_3757_13&#39;, &#39;L15-0457E-1135N_1831_3648_13&#39;] . scene = VALID_SCENES[0:] . from time import sleep for scene in VALID_SCENES: save_predictions(scene) show_complete_preds(*get_saved_preds(scene), scene) time.sleep(1) . . #Initiating Run2 . --Experiment Run: 2 . del learn . learn = unet_learner(dls, # DataLoaders ARCHITECTURE, # xResNet34 loss_func = loss_func, # Weighted cross entropy loss opt_func = Adam, # Adam optimizer metrics = [Dice(), foreground_acc], # Custom metrics self_attention = False, cbs = [SaveModelCallback( monitor=&#39;dice&#39;, comp=np.greater, fname=&#39;best-model&#39; )] ) . learn.summary() . DynamicUnet (Input shape: 12) ============================================================================ Layer (type) Output Shape Param # Trainable ============================================================================ 12 x 32 x 128 x 128 Conv2d 864 False BatchNorm2d 64 True ReLU Conv2d 9216 False BatchNorm2d 64 True ReLU ____________________________________________________________________________ 12 x 64 x 128 x 128 Conv2d 18432 False BatchNorm2d 128 True ReLU MaxPool2d Conv2d 36864 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True Sequential ReLU Conv2d 36864 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True Sequential ReLU Conv2d 36864 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True Sequential ReLU ____________________________________________________________________________ 12 x 128 x 32 x 32 Conv2d 73728 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 128 x 32 x 32 Conv2d 8192 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True Sequential ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True Sequential ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True Sequential ReLU ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 294912 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 32768 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True Sequential ReLU ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 1179648 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 131072 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True Sequential ReLU Conv2d 2359296 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True Sequential ReLU BatchNorm2d 1024 True ReLU ____________________________________________________________________________ 12 x 1024 x 8 x 8 Conv2d 4719616 True ReLU ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 4719104 True ReLU ____________________________________________________________________________ 12 x 1024 x 8 x 8 Conv2d 525312 True ReLU PixelShuffle BatchNorm2d 512 True Conv2d 2359808 True ReLU Conv2d 2359808 True ReLU ReLU ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 525312 True ReLU PixelShuffle BatchNorm2d 256 True Conv2d 1327488 True ReLU Conv2d 1327488 True ReLU ReLU ____________________________________________________________________________ 12 x 768 x 32 x 32 Conv2d 295680 True ReLU PixelShuffle BatchNorm2d 128 True Conv2d 590080 True ReLU Conv2d 590080 True ReLU ReLU ____________________________________________________________________________ 12 x 512 x 64 x 64 Conv2d 131584 True ReLU PixelShuffle BatchNorm2d 128 True ____________________________________________________________________________ 12 x 96 x 128 x 128 Conv2d 165984 True ReLU Conv2d 83040 True ReLU ReLU ____________________________________________________________________________ 12 x 384 x 128 x 12 Conv2d 37248 True ReLU PixelShuffle ResizeToOrig MergeLayer Conv2d 88308 True ReLU Conv2d 88308 True Sequential ReLU ____________________________________________________________________________ 12 x 2 x 255 x 255 Conv2d 200 True ____________________________________________________________________________ Total params: 41,240,400 Total trainable params: 19,953,648 Total non-trainable params: 21,286,752 Optimizer used: &lt;function Adam at 0x7eff70070cb0&gt; Loss function: FlattenedLoss of CrossEntropyLoss() Model frozen up to parameter group #2 Callbacks: - TrainEvalCallback - Recorder - ProgressCallback - SaveModelCallback . . learn.model . DynamicUnet( (layers): ModuleList( (0): Sequential( (0): ConvLayer( (0): Conv2d(3, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (3): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (4): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (5): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (3): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (6): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (3): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (4): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (5): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (7): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) ) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() (3): Sequential( (0): ConvLayer( (0): Conv2d(512, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (1): ConvLayer( (0): Conv2d(1024, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) ) (4): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (5): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(384, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(384, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (6): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(384, 768, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (7): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(192, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(96, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (8): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(96, 384, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (9): ResizeToOrig() (10): MergeLayer() (11): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(99, 99, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (1): ConvLayer( (0): Conv2d(99, 99, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (12): ConvLayer( (0): Conv2d(99, 2, kernel_size=(1, 1), stride=(1, 1)) ) ) ) . . . learn.lr_find(suggestions=False) . # Run2 learn.unfreeze() learn.fit_one_cycle( EPOCHS, lr_max=slice(lr_max/ENCODER_FACTOR, lr_max), cbs=[WandbCallback()] ) . epoch train_loss valid_loss dice foreground_acc time . 0 | 1.937740 | 0.952615 | 0.182434 | 0.229873 | 00:43 | . 1 | 0.905160 | 0.588179 | 0.333524 | 0.360573 | 00:46 | . 2 | 0.587758 | 0.485159 | 0.409871 | 0.416817 | 00:47 | . 3 | 0.461647 | 0.448966 | 0.419921 | 0.572241 | 00:47 | . 4 | 0.431045 | 0.412626 | 0.434957 | 0.437551 | 00:47 | . 5 | 0.384136 | 0.399362 | 0.441417 | 0.484893 | 00:48 | . 6 | 0.372647 | 0.469187 | 0.417687 | 0.342526 | 00:49 | . 7 | 0.358055 | 0.401312 | 0.433877 | 0.474332 | 00:48 | . 8 | 0.335158 | 0.426308 | 0.409999 | 0.420248 | 00:49 | . 9 | 0.340261 | 0.388585 | 0.453323 | 0.680999 | 00:49 | . 10 | 0.350476 | 0.424114 | 0.427702 | 0.423918 | 00:49 | . 11 | 0.340361 | 0.830213 | 0.363972 | 0.274424 | 00:49 | . 12 | 0.347802 | 0.396467 | 0.447701 | 0.424461 | 00:49 | . 13 | 0.347854 | 0.361305 | 0.471549 | 0.464989 | 00:49 | . 14 | 0.322265 | 0.496307 | 0.421688 | 0.320692 | 00:49 | . 15 | 0.312543 | 0.419182 | 0.407756 | 0.352709 | 00:49 | . 16 | 0.304165 | 0.388873 | 0.451288 | 0.371343 | 00:48 | . 17 | 0.299325 | 0.477858 | 0.439302 | 0.351467 | 00:48 | . 18 | 0.308990 | 0.409736 | 0.413224 | 0.461884 | 00:48 | . 19 | 0.288411 | 0.498319 | 0.370609 | 0.280490 | 00:48 | . 20 | 0.281468 | 0.360414 | 0.485021 | 0.485740 | 00:48 | . 21 | 0.274416 | 0.418477 | 0.475279 | 0.414546 | 00:48 | . 22 | 0.278710 | 0.325033 | 0.520833 | 0.521762 | 00:48 | . 23 | 0.270224 | 0.359991 | 0.506736 | 0.490314 | 00:49 | . 24 | 0.278280 | 0.342068 | 0.522744 | 0.638762 | 00:48 | . 25 | 0.268276 | 0.384951 | 0.448934 | 0.658303 | 00:48 | . 26 | 0.266887 | 0.318082 | 0.537392 | 0.628973 | 00:48 | . 27 | 0.262979 | 0.364846 | 0.507638 | 0.516916 | 00:48 | . 28 | 0.257349 | 0.333423 | 0.531541 | 0.588342 | 00:48 | . 29 | 0.254129 | 0.337612 | 0.534185 | 0.635413 | 00:47 | . 30 | 0.256843 | 0.371552 | 0.523938 | 0.519276 | 00:47 | . 31 | 0.252976 | 0.376065 | 0.502235 | 0.588909 | 00:48 | . 32 | 0.250810 | 0.393963 | 0.521790 | 0.486784 | 00:48 | . 33 | 0.246234 | 0.375275 | 0.519142 | 0.489137 | 00:48 | . 34 | 0.245064 | 0.331335 | 0.528236 | 0.686900 | 00:48 | . 35 | 0.246199 | 0.377710 | 0.537571 | 0.545870 | 00:47 | . 36 | 0.244448 | 0.368422 | 0.542517 | 0.553300 | 00:49 | . 37 | 0.241390 | 0.349010 | 0.519374 | 0.491989 | 00:48 | . 38 | 0.243630 | 0.359600 | 0.509863 | 0.521250 | 00:48 | . 39 | 0.241627 | 0.336892 | 0.539313 | 0.583476 | 00:48 | . 40 | 0.238271 | 0.367133 | 0.536665 | 0.515662 | 00:47 | . 41 | 0.232399 | 0.347052 | 0.545673 | 0.578082 | 00:48 | . 42 | 0.232242 | 0.319940 | 0.536428 | 0.673036 | 00:48 | . 43 | 0.235520 | 0.320792 | 0.553474 | 0.609017 | 00:47 | . 44 | 0.226998 | 0.326368 | 0.549632 | 0.638580 | 00:48 | . 45 | 0.229752 | 0.361821 | 0.542705 | 0.521525 | 00:48 | . 46 | 0.231764 | 0.356062 | 0.544539 | 0.571413 | 00:48 | . 47 | 0.226325 | 0.372531 | 0.541578 | 0.529744 | 00:48 | . 48 | 0.226063 | 0.374176 | 0.542866 | 0.539490 | 00:48 | . 49 | 0.223156 | 0.416989 | 0.514208 | 0.441924 | 00:48 | . 50 | 0.225011 | 0.389048 | 0.541989 | 0.558846 | 00:48 | . 51 | 0.221490 | 0.363521 | 0.539199 | 0.517616 | 00:48 | . 52 | 0.221223 | 0.344703 | 0.554917 | 0.570877 | 00:48 | . 53 | 0.219953 | 0.349854 | 0.550852 | 0.559267 | 00:47 | . 54 | 0.220182 | 0.371416 | 0.547601 | 0.532858 | 00:48 | . 55 | 0.218004 | 0.387494 | 0.507081 | 0.445336 | 00:47 | . 56 | 0.216417 | 0.355569 | 0.554721 | 0.555101 | 00:48 | . 57 | 0.214520 | 0.388316 | 0.538123 | 0.508856 | 00:48 | . 58 | 0.219770 | 0.350133 | 0.553124 | 0.555288 | 00:48 | . 59 | 0.213634 | 0.380796 | 0.545702 | 0.530716 | 00:48 | . 60 | 0.214770 | 0.403674 | 0.544516 | 0.526405 | 00:48 | . 61 | 0.212837 | 0.382615 | 0.547741 | 0.530949 | 00:49 | . 62 | 0.210907 | 0.385081 | 0.551419 | 0.559432 | 00:50 | . 63 | 0.211821 | 0.383210 | 0.538854 | 0.495931 | 00:49 | . 64 | 0.211744 | 0.366420 | 0.551287 | 0.553639 | 00:49 | . 65 | 0.208235 | 0.393033 | 0.544909 | 0.509530 | 00:49 | . 66 | 0.209825 | 0.404355 | 0.536005 | 0.474010 | 00:49 | . 67 | 0.210346 | 0.362994 | 0.552082 | 0.538402 | 00:49 | . 68 | 0.208779 | 0.372804 | 0.547688 | 0.514751 | 00:48 | . 69 | 0.209830 | 0.351810 | 0.555377 | 0.548285 | 00:48 | . 70 | 0.207887 | 0.386565 | 0.541370 | 0.496355 | 00:49 | . 71 | 0.206442 | 0.377267 | 0.548791 | 0.524507 | 00:48 | . 72 | 0.207366 | 0.374546 | 0.548827 | 0.523453 | 00:48 | . 73 | 0.205153 | 0.365717 | 0.549390 | 0.525388 | 00:49 | . 74 | 0.207726 | 0.367150 | 0.552252 | 0.542283 | 00:48 | . 75 | 0.208129 | 0.372454 | 0.549932 | 0.532464 | 00:48 | . 76 | 0.208461 | 0.360281 | 0.553864 | 0.548102 | 00:48 | . 77 | 0.207639 | 0.372237 | 0.550863 | 0.531641 | 00:48 | . 78 | 0.208036 | 0.364154 | 0.553543 | 0.545880 | 00:48 | . 79 | 0.206991 | 0.361695 | 0.552300 | 0.540092 | 00:47 | . Better model found at epoch 0 with dice value: 0.1824341691331724. Better model found at epoch 1 with dice value: 0.333523651466895. Better model found at epoch 2 with dice value: 0.4098708280811938. Better model found at epoch 3 with dice value: 0.4199211105853764. Better model found at epoch 4 with dice value: 0.4349567064541659. Better model found at epoch 5 with dice value: 0.4414173943941379. Better model found at epoch 9 with dice value: 0.4533229756356818. Better model found at epoch 13 with dice value: 0.4715493178986515. Better model found at epoch 20 with dice value: 0.48502134642674577. Better model found at epoch 22 with dice value: 0.5208334194588561. Better model found at epoch 24 with dice value: 0.5227439605738604. Better model found at epoch 26 with dice value: 0.5373924110580985. Better model found at epoch 35 with dice value: 0.5375711386569465. Better model found at epoch 36 with dice value: 0.5425170370282605. Better model found at epoch 41 with dice value: 0.5456728971466592. Better model found at epoch 43 with dice value: 0.5534739872514315. Better model found at epoch 52 with dice value: 0.5549168145010914. Better model found at epoch 69 with dice value: 0.5553773335762703. . . learn.recorder.plot_loss() . learn.save(&#39;xres34-best-long&#39;) . run.finish() . --Experiment Run: 3 . learn.save(&#39;xres34-best-long&#39;) . del learn . BATCH_SIZE = 3 # 3 for xresnet50, 12 for xresnet34 with Tesla P100 (16GB) TILES_PER_SCENE = 16 ARCHITECTURE = xresnet50 EPOCHS = 40 CLASS_WEIGHTS = [0.25,0.75] LR_MAX = 3e-4 ENCODER_FACTOR = 10 CODES = [&#39;Land&#39;,&#39;Building&#39;] . # Weights and Biases config config_dictionary = dict( bs=BATCH_SIZE, tiles_per_scene=TILES_PER_SCENE, architecture = str(ARCHITECTURE), epochs = EPOCHS, class_weights = CLASS_WEIGHTS, lr_max = LR_MAX, encoder_factor = ENCODER_FACTOR ) . learn = unet_learner(dls, # DataLoaders ARCHITECTURE, # xResNet50 loss_func = loss_func, # Weighted cross entropy loss opt_func = Adam, # Adam optimizer metrics = [Dice(), foreground_acc], # Custom metrics self_attention = False, cbs = [SaveModelCallback( monitor=&#39;dice&#39;, comp=np.greater, fname=&#39;best-model-0&#39; )] ) . learn.model . DynamicUnet( (layers): ModuleList( (0): Sequential( (0): ConvLayer( (0): Conv2d(3, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (3): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (4): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (5): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (3): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (6): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (3): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (4): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (5): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (7): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) ) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() (3): Sequential( (0): ConvLayer( (0): Conv2d(2048, 4096, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (1): ConvLayer( (0): Conv2d(4096, 2048, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) ) (4): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(2048, 4096, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(2048, 2048, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(2048, 2048, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (5): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(2048, 4096, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(1536, 1536, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(1536, 1536, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (6): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(1536, 3072, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (7): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(576, 288, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(288, 288, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (8): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(288, 1152, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (9): ResizeToOrig() (10): MergeLayer() (11): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(291, 291, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (1): ConvLayer( (0): Conv2d(291, 291, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (12): ConvLayer( (0): Conv2d(291, 2, kernel_size=(1, 1), stride=(1, 1)) ) (13): ToTensorBase(tensor_cls=&lt;class &#39;fastai.torch_core.TensorBase&#39;&gt;) ) ) . . learn.unfreeze() learn.fit_one_cycle( EPOCHS, lr_max=slice(lr_max/ENCODER_FACTOR, lr_max), cbs=[WandbCallback()] ) . learn = unet_learner(dls, # DataLoaders ARCHITECTURE, # xResNet50 loss_func = loss_func, # Weighted cross entropy loss opt_func = Adam, # Adam optimizer metrics = [Dice(), foreground_acc], # Custom metrics self_attention = False, cbs = [SaveModelCallback( monitor=&#39;dice&#39;, comp=np.greater, fname=&#39;best-model&#39; )] ) . Downloading: &#34;https://s3.amazonaws.com/fast-ai-modelzoo/xrn50_940.pth&#34; to /root/.cache/torch/hub/checkpoints/xrn50_940.pth . . learn.model . DynamicUnet( (layers): ModuleList( (0): Sequential( (0): ConvLayer( (0): Conv2d(3, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (3): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (4): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): ConvLayer( (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (5): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (3): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (6): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (3): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (4): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (5): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) (7): Sequential( (0): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential( (0): AvgPool2d(kernel_size=2, stride=2, padding=0) (1): ConvLayer( (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (act): ReLU(inplace=True) ) (1): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (2): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (1): ConvLayer( (0): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (2): ConvLayer( (0): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) ) ) (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() (3): Sequential( (0): ConvLayer( (0): Conv2d(2048, 4096, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (1): ConvLayer( (0): Conv2d(4096, 2048, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) ) (4): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(2048, 4096, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(2048, 2048, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(2048, 2048, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (5): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(2048, 4096, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(1536, 1536, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(1536, 1536, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (6): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(1536, 3072, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (7): UnetBlock( (shuf): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (bn): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv1): ConvLayer( (0): Conv2d(576, 288, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (conv2): ConvLayer( (0): Conv2d(288, 288, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (relu): ReLU() ) (8): PixelShuffle_ICNR( (0): ConvLayer( (0): Conv2d(288, 1152, kernel_size=(1, 1), stride=(1, 1)) (1): ReLU() ) (1): PixelShuffle(upscale_factor=2) ) (9): ResizeToOrig() (10): MergeLayer() (11): ResBlock( (convpath): Sequential( (0): ConvLayer( (0): Conv2d(291, 291, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU() ) (1): ConvLayer( (0): Conv2d(291, 291, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) ) ) (idpath): Sequential() (act): ReLU(inplace=True) ) (12): ConvLayer( (0): Conv2d(291, 2, kernel_size=(1, 1), stride=(1, 1)) ) ) ) . . learn.summary() . DynamicUnet (Input shape: 12) ============================================================================ Layer (type) Output Shape Param # Trainable ============================================================================ 12 x 32 x 128 x 128 Conv2d 864 False BatchNorm2d 64 True ReLU Conv2d 9216 False BatchNorm2d 64 True ReLU ____________________________________________________________________________ 12 x 64 x 128 x 128 Conv2d 18432 False BatchNorm2d 128 True ReLU MaxPool2d Conv2d 4096 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True ReLU ____________________________________________________________________________ 12 x 256 x 64 x 64 Conv2d 16384 False BatchNorm2d 512 True Conv2d 16384 False BatchNorm2d 512 True ReLU ____________________________________________________________________________ 12 x 64 x 64 x 64 Conv2d 16384 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True ReLU ____________________________________________________________________________ 12 x 256 x 64 x 64 Conv2d 16384 False BatchNorm2d 512 True Sequential ReLU ____________________________________________________________________________ 12 x 64 x 64 x 64 Conv2d 16384 False BatchNorm2d 128 True ReLU Conv2d 36864 False BatchNorm2d 128 True ReLU ____________________________________________________________________________ 12 x 256 x 64 x 64 Conv2d 16384 False BatchNorm2d 512 True Sequential ReLU ____________________________________________________________________________ 12 x 128 x 64 x 64 Conv2d 32768 False BatchNorm2d 256 True ReLU ____________________________________________________________________________ 12 x 128 x 32 x 32 Conv2d 147456 False BatchNorm2d 256 True ReLU ____________________________________________________________________________ 12 x 512 x 32 x 32 Conv2d 65536 False BatchNorm2d 1024 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 512 x 32 x 32 Conv2d 131072 False BatchNorm2d 1024 True ReLU ____________________________________________________________________________ 12 x 128 x 32 x 32 Conv2d 65536 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU ____________________________________________________________________________ 12 x 512 x 32 x 32 Conv2d 65536 False BatchNorm2d 1024 True Sequential ReLU ____________________________________________________________________________ 12 x 128 x 32 x 32 Conv2d 65536 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU ____________________________________________________________________________ 12 x 512 x 32 x 32 Conv2d 65536 False BatchNorm2d 1024 True Sequential ReLU ____________________________________________________________________________ 12 x 128 x 32 x 32 Conv2d 65536 False BatchNorm2d 256 True ReLU Conv2d 147456 False BatchNorm2d 256 True ReLU ____________________________________________________________________________ 12 x 512 x 32 x 32 Conv2d 65536 False BatchNorm2d 1024 True Sequential ReLU ____________________________________________________________________________ 12 x 256 x 32 x 32 Conv2d 131072 False BatchNorm2d 512 True ReLU ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 589824 False BatchNorm2d 512 True ReLU ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 262144 False BatchNorm2d 2048 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 524288 False BatchNorm2d 2048 True ReLU ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 262144 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 262144 False BatchNorm2d 2048 True Sequential ReLU ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 262144 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 262144 False BatchNorm2d 2048 True Sequential ReLU ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 262144 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 262144 False BatchNorm2d 2048 True Sequential ReLU ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 262144 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 262144 False BatchNorm2d 2048 True Sequential ReLU ____________________________________________________________________________ 12 x 256 x 16 x 16 Conv2d 262144 False BatchNorm2d 512 True ReLU Conv2d 589824 False BatchNorm2d 512 True ReLU ____________________________________________________________________________ 12 x 1024 x 16 x 16 Conv2d 262144 False BatchNorm2d 2048 True Sequential ReLU ____________________________________________________________________________ 12 x 512 x 16 x 16 Conv2d 524288 False BatchNorm2d 1024 True ReLU ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 2359296 False BatchNorm2d 1024 True ReLU ____________________________________________________________________________ 12 x 2048 x 8 x 8 Conv2d 1048576 False BatchNorm2d 4096 True ____________________________________________________________________________ [] AvgPool2d ____________________________________________________________________________ 12 x 2048 x 8 x 8 Conv2d 2097152 False BatchNorm2d 4096 True ReLU ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 1048576 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True ReLU ____________________________________________________________________________ 12 x 2048 x 8 x 8 Conv2d 1048576 False BatchNorm2d 4096 True Sequential ReLU ____________________________________________________________________________ 12 x 512 x 8 x 8 Conv2d 1048576 False BatchNorm2d 1024 True ReLU Conv2d 2359296 False BatchNorm2d 1024 True ReLU ____________________________________________________________________________ 12 x 2048 x 8 x 8 Conv2d 1048576 False BatchNorm2d 4096 True Sequential ReLU BatchNorm2d 4096 True ReLU ____________________________________________________________________________ 12 x 4096 x 8 x 8 Conv2d 75501568 True ReLU ____________________________________________________________________________ 12 x 2048 x 8 x 8 Conv2d 75499520 True ReLU ____________________________________________________________________________ 12 x 4096 x 8 x 8 Conv2d 8392704 True ReLU PixelShuffle BatchNorm2d 2048 True Conv2d 37750784 True ReLU Conv2d 37750784 True ReLU ReLU ____________________________________________________________________________ 12 x 4096 x 16 x 16 Conv2d 8392704 True ReLU PixelShuffle BatchNorm2d 1024 True Conv2d 21235200 True ReLU Conv2d 21235200 True ReLU ReLU ____________________________________________________________________________ 12 x 3072 x 32 x 32 Conv2d 4721664 True ReLU PixelShuffle BatchNorm2d 512 True Conv2d 9438208 True ReLU Conv2d 9438208 True ReLU ReLU ____________________________________________________________________________ 12 x 2048 x 64 x 64 Conv2d 2099200 True ReLU PixelShuffle BatchNorm2d 128 True ____________________________________________________________________________ 12 x 288 x 128 x 12 Conv2d 1493280 True ReLU Conv2d 746784 True ReLU ReLU ____________________________________________________________________________ 12 x 1152 x 128 x 1 Conv2d 332928 True ReLU PixelShuffle ResizeToOrig MergeLayer Conv2d 762420 True ReLU Conv2d 762420 True Sequential ReLU ____________________________________________________________________________ 12 x 2 x 255 x 255 Conv2d 584 True ____________________________________________________________________________ Total params: 339,089,232 Total trainable params: 315,615,216 Total non-trainable params: 23,474,016 Optimizer used: &lt;function Adam at 0x7ff189be5680&gt; Loss function: FlattenedLoss of CrossEntropyLoss() Model frozen up to parameter group #2 Callbacks: - TrainEvalCallback - Recorder - ProgressCallback - SaveModelCallback . . learn.lr_find(suggestions=False) . !nvidia-smi . Tue Jun 8 16:12:57 2021 +--+ | NVIDIA-SMI 465.27 Driver Version: 460.32.03 CUDA Version: 11.2 | |-+-+-+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla T4 Off | 00000000:00:04.0 Off | 0 | | N/A 72C P0 32W / 70W | 13552MiB / 15109MiB | 0% Default | | | | N/A | +-+-+-+ +--+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| +--+ . import torch, gc gc.collect() torch.cuda.empty_cache() . learn.unfreeze() learn.fit_one_cycle( EPOCHS, lr_max=slice(lr_max/ENCODER_FACTOR, lr_max), cbs=[WandbCallback()] ) . learn.save(&#39;xres43-best-55&#39;) . Path(&#39;models/xres43-best-55.pth&#39;) . run.finish() . Waiting for W&amp;B process to finish, PID 15662Program ended successfully. Find user logs for this run at: /content/gdrive/Shareddrives/dataset/s7/SN7_buildings_train/train/L15-1716E-1211N_6864_3345_13/wandb/run-20210607_160231-1bj2r9kt/logs/debug.log Find internal logs for this run at: /content/gdrive/Shareddrives/dataset/s7/SN7_buildings_train/train/L15-1716E-1211N_6864_3345_13/wandb/run-20210607_160231-1bj2r9kt/logs/debug-internal.log Synced 4 W&amp;B file(s), 0 media file(s), 0 artifact file(s) and 0 other file(s) Synced clean-plasma-3: https://wandb.ai/priyank7n/s7/runs/1bj2r9kt Discussion . I&#39;m not sure how to rate the results because I don&#39;t have any comparison. A Dice score of 0.57 doesn&#39;t sound great. But considering how difficult the dataset is and that I didn&#39;t customize the architecture at all, I&#39;m quite pleased with the result. There is a lot to improve however! The original SpaceNet7 challenge required recognizing individual buildings and tracking them trough time, that&#39;s something I&#39;d like to work on in the future. . What worked? . Using a pretrained encoder. | Ignoring most images of the dataset. I tried using 5 instead of 1 images per scene, which increased training time by 5 but did not improve the results significantly. | Standard data augmentations. Without them, the model started to overfit sooner. | Undersampling. While it did not have a large effect, it sped up training a little bit and it helped the accuracy. | Weighted cross-entropy loss. Without the weights, the model had a strong bias towards the dominating background class and failed to recognize many buildings. | . What didn&#39;t? . I hoped to get faster training with the Mish activation function, but training was unstable. | Dice loss instead of cross-entropy loss was unstable as well. | I tried adding self-attention to the U-Net, I hoped it would help classifying larger structures. I did not notice a significant difference. | A deeper xResNet50 encoder that I tried increased training time 6-fold, but did not improve results. | . Other ideas to improve the results . Better data processing: using overlapping tiles, scaling up the image tiles | Dynamic thresholding for turning the predicted probabilities into a binary mask. | Implement recent advancements in segmentation models, ie UNet with ASPP or Eff-UNet | More compute: Deeper models. Use cross-validation with several folds to utilize all 60 scenes. Ensemble different models. | . Thank you for reading this far! The challenge was fun and I learned a lot. There is also a lot of room for improvement and work to do :) .",
            "url": "https://priyank7n.me/2021/05/06/SatFoot.html",
            "relUrl": "/2021/05/06/SatFoot.html",
            "date": " • May 6, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Reproducing Reformer: Our Amazing Submission & Team Experience",
            "content": "Where we all met? here❤️ . The Challenge . Way back in October 2020 the Papers With Code ML Reproducibility Challenge 2020 was launched and shared in the fast.ai forums. A few of us jumped at the chance to test our ML knowledge and push our skills. Fast forward 110 days since that initial post and we delivered our Reformer Reproducibility submission via OpenReview!!🤩 . Our Whole Project is Documented here : Project . The Wandb reports we made : reports . Here are a few reflections on our experience: what we enjoyed, tools we used and what we would have done differently: . TLDR; . Working as a team pushes your motivation, your skills and your throughput | nbdev for development, Weights &amp; Biases for tracking and Discord for communication | We could have better used task/project management tools more, maybe we needed a different tool | Next time we’ll start experiments sooner and maybe pick a more practical paper | It was a massive learning experience and a lot of fun | . . Why participate . Implementing code from scratch is much more enjoyable and meaningful when there is a direct application, e.g. working towards this reproducibility challenge. Spending weeks and months focussed on a single paper forces you to understand the paper down to the last full stop. It also gives you a great appreciation of how difficult writing a good paper is, you see almost every word and sentence is chosen carefully to communicate a particular concept, problem or model setting. . N heads are better than one a.k.a. Multihead Attention . Our team was distributed across 6 countries and everyone had a somewhat different background, set of skills and personality. This mix was definitely beneficial for getting things done much more smoothly. Having 2 x N eyes researching implementation information or reviewing code really improved coverage and sped up the entire process. It also makes debugging much faster! . . Writing code that the entire team will use also meant writing cleaner code with more tests so that it was as clear as possible for your teammates. And finally, during a long project like this it’s easy to get distracted or lazy, however seeing everyone else delivering great work quickly pulls you back into line! . . Good tools Are key for us : A good tool improves the way you work. A great tool improves the way you think. . Read more: https://www.wisesayings.com/tool-quotes/#ixzz6mZj38LCP . nbdev . The nbdev literate programming environment from fast.ai was super convenient to minimise the project’s development friction. Writing tests as we developed meant that we caught multiple bugs early and auto-generation of docs lends itself immensely to the reproducibility of your code. Most of us will be using this again for our next projects. . Weights &amp; Biases . Weights &amp; Biases generously gave us a team account which enabled us all to log our experiments to a single project. Being directly able to link your runs and results to the final report was really nice. Also it&#39;s pretty exciting monitoring 10+ experiments live! . Discord . A Discord server worked really well for all our chat and voice communication. Frequent calls to catchup and agree on next steps were super useful. Todo lists and core pieces of code often ended up as pinned messages for quick reference and linking Github activity to a channel was useful for keeping an eye on new commits to the repo. . Overleaf . When it came to writing the final report in latex, Overleaf was a wonderful tool for collaborative editing. . ReviewNB . The ReviewNB app on GitHub was very useful for visualizing diffs in notebooks. . . Learn from the best . The Reformer architecture had several complex parts, and having Phil Wang&#39;s and HuggingFace&#39;s Github code was very helpful to understand design decisions and fix issues. . Things we can improve for the next time . Start experiments early . We started our experiments quite late in the project; as we aimed to reimplement Reformer in Pytorch (with reference to existing implementations) about ~90% of our time was spent on ensuring our implementation was faithful to the paper and that it was working correctly. In retrospect starting experiments earlier would have allowed more in depth exploration of what we observed while testing. Full scale experiments have a way of inducing problems you didn’t foresee during the implementation phase... . Task distribution and coordination . When working in a distributed and decentralized team, efficient task allocation and tracking is important. Early in the project todo lists lived in people’s heads, or were quickly buried under 50 chat messages. This was suboptimal for a number of reasons, including that it made involving new people in the project more challenging as they could not easily identify where they could best contribute. . We made a switch to Trello to better track open tasks. It worked reasonably well however its effectiveness was probably proportional to how much time a couple of team members had to review the kanban board, advocate for its use and focus the team’s attention there. The extra friction associated with needing to use another tool unconnected to Github or Discord was probably the reason for why we didn’t use it as much as we could have. Integrating Trello into our workflow or giving Github Projects a trial could have been useful. . More feedback . We had originally intended to get feedback from the fastai community during the project. In the end we were too late in sharing our material, so there wasn’t time for much feedback. Early feedback would have been very useful and the project might have benefited from some periodic summary of accomplishments and current problems. We could have solicited additional feedback from the authors too. . Distributed training . This was our first exposure to distributed training and unfortunately we had a lot of issues with it. We were also unable to log the results from distributed runs properly to Weights &amp; Biases. This slowed down our experiment iteration speed and is why we could not train our models for as long as we would have preferred. . . Choice of paper to reproduce . It would have been useful to calculate a rough estimate of the compute budget the paper’s experiments required before jumping into it. In the latter stages of the project we realised that we would be unable to fully replicate some of the paper’s experiments, but instead had to run scaled down versions. In addition, where your interest sits between theoretical and practical papers should be considered when selecting a paper for the challenge. . More tools . We could have tried even more handy tools such as knockknock to alert us when models are finished training and Github Projects for task management. . Some final thoughts . We came out of this project even more motivated compared to how we entered; a great indication that it was both enjoyable and useful for us! Our advice would be to not hesitate to join events like this one and challenge yourself, and try and find one or more other folks in the forums or Discord to work with. After successfully delivering our submission to the challenge we are all eager to work together again on our next project, stay tuned for more! . . Thanks for Reading This Far &#128591; . As always, I would love to hear your feedback, what could have been written better or clearer, you can find me on twitter &amp; Linkedin: twitter Linkedin .",
            "url": "https://priyank7n.me/nlp/reformer/transformers/language-modelling/2021/02/19/reformer-reproducibility-challenge.html",
            "relUrl": "/nlp/reformer/transformers/language-modelling/2021/02/19/reformer-reproducibility-challenge.html",
            "date": " • Feb 19, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "COVID-19 Infection Detection Using Deep Learning",
            "content": "Setup . Dataset is acquired from kaggle.link SARS-CoV-2 CT scan dataset is a public dataset, containing 1252 CT scans (computed tomography scan) from SARS-CoV-2 infected patients (COVID-19) and 1230 CT scans for SARS-CoV-2 non-infected patients. The dataset has been collected from real patients in Sao Paulo, Brazil. The dataset is available in kaggle. . import opendatasets as od dataset_url = &#39;https://www.kaggle.com/plameneduardo/sarscov2-ctscan-dataset&#39; od.download(dataset_url) . . 2%|▏ | 5.00M/230M [00:00&lt;00:06, 34.4MB/s] . Downloading sarscov2-ctscan-dataset.zip to ./sarscov2-ctscan-dataset . 100%|██████████| 230M/230M [00:04&lt;00:00, 52.3MB/s] . . path=Path(&#39;sarscov2-ctscan-dataset&#39;) . The Dataset contains two folders namely COVID &amp; non-COVID having CT Scan Images of patients: . path.ls() . . (#2) [Path(&#39;sarscov2-ctscan-dataset/COVID&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID&#39;)] . Preprocessing . Exploring Dataset Structure and displaying sample CT Scan directories: . path.ls() . . (#2) [Path(&#39;sarscov2-ctscan-dataset/COVID&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID&#39;)] . There are 1252 CT scan images from SARS-CoV-2 infected patients. . (path/&#39;COVID&#39;).ls() . . (#1252) [Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (1).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (10).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (100).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (1000).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (1001).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (1002).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (1003).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (1004).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (1005).png&#39;),Path(&#39;sarscov2-ctscan-dataset/COVID/Covid (1006).png&#39;)...] . There are 1230 CT scan images from SARS-CoV-2 non-infected patients. . (path/&#39;non-COVID&#39;).ls() . . (#1229) [Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (1).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (10).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (100).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (1000).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (1001).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (1002).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (1003).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (1004).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (1005).png&#39;),Path(&#39;sarscov2-ctscan-dataset/non-COVID/Non-Covid (1006).png&#39;)...] . Visualizing the Images: Lets look at some raw images in the dataset: . import PIL #looking into the images downloaded img1 = PIL.Image.open((path/&#39;COVID&#39;).ls()[0]) img1 . . Creating a Datablock . DataBlock API :We divide the dataset as train and valid set and use the random_state argument in order to replicate the result.The valid_pct argument represents the proportion of the dataset to include in the valid (in our case 20%). Presizing is done and Transformations are applied to images keeping 75% of the images and then normalized according to the imagenet stats for applying Transfer Learning later. . Creating Dataloaders . def get_dls(bs,size): dblock = DataBlock(blocks=(ImageBlock, CategoryBlock), get_items=get_image_files, get_y=parent_label, splitter=RandomSplitter(valid_pct=0.2, seed=42), item_tfms=Resize(460), #presizing is done batch_tfms=[*aug_transforms(size=size,min_scale=0.75), Normalize.from_stats(*imagenet_stats)]) return dblock.dataloaders(path,bs=bs) . To Create dataloaders we use DataBlock API of fast ai: We use images of size 224*224 and a single batch containing 224 images. . dls=get_dls(224,224) . Visualizing the Dataloaders . The images in the dataloaders look like: . dls.show_batch(nrows=3, figsize=(7,6)) . . A batch of images in a grid look like: . @patch @delegates(to=draw_label, but=[&quot;font_color&quot;, &quot;location&quot;, &quot;draw_rect&quot;, &quot;fsize_div_factor&quot;, &quot;font_path&quot;, &quot;font_size&quot;]) def show_batch_grid(self:TfmdDL, b=None, n=20, ncol=4, show=True, unique=False, unique_each=True, font_path=None, font_size=20, **kwargs): &quot;&quot;&quot;Show a batch of images Key Params: * n: No. of images to display * n_col: No. of columns in the grid * unique: Display the same image with different augmentations * unique_each: If True, displays a different img on each call * font_path: Path to the `.ttf` font file. Required to display labels * font_size: Size of the font &quot;&quot;&quot; if font_path is not None: self.set_font_path(font_path) if not hasattr(self, &#39;font_path&#39;): self.font_path = font_path if unique: old_get_idxs = self.get_idxs if unique_each: i = np.random.choice(self.n) self.get_idxs = partial(itertools.repeat, i) else: self.get_idxs = lambda: Inf.zeros if b is None: b = self.one_batch() if not show: return self._pre_show_batch(b, max_n=n) _,__, b = self._pre_show_batch(b, max_n=n) if unique: self.get_idxs = old_get_idxs return make_img_grid([draw_label(i, font_path=self.font_path, font_size=font_size) for i in b], ncol=ncol, img_size=None) . . Transfer Learning . The Resnet50 model . What and why did we used Transfer Learning . Transfer learning is meaning use a pre-trained model to build our classifier. A pre-trained model is a model that has been previously trained on a dataset. The model comprehends the updated weights and bias. Using a pre-trained model you are saving time and computational resources. Another avantage is that pre-trained models often perform better that architecture designed from scratch. | To better understand this point, suppose we want to build a classifier able to sort different sailboat types. A model pre-trained on ships would have already capture in its first layers some boat features, learning faster and with better accuracy among the different sailboat types. | . | The Resnet50 architecture: . Resnet50 generally is considered a good choice as first architecture to test, it shows good performance without an excessive size allowing to use a higher batch size and thus less computation time. For this reason, before to test more complex architectures Resnet50 is a good compromise. | Residual net have been ideated to solve the problem of the vanishing gradient. Highly intricate networks with a large number of hidden layer are working effectively in solving complicated tasks. Their structures allow them to catch pattern in complicated data. When we train the network the early layer tend to be trained slower (the gradient are smaller during backpropagation). The initial layers are important because they learn the basic feature of an object (edge, corner and so on). Failing to proper train these layers lead to a decrease in the overall accuracy of the model. | Residual neural network have been ideated to solve this issue. The Resnet model presents the possibility to skip the training of some layer during the initial training. The skipped layer is reusing the learned weights from the previous layer. Original research article | . | Test the Resnet34 architecture with our dataset: . Now we are going to test how the FastaAI implementation of this architechture works with the COVID dataset. | Create the convolutional neural network First we will create the convolutional neural network based on this architechture, to do this we can use the following code block which uses FastAI ( cnn_learner previously create_cnn) function. We pass the loaded data, specify the model, pass error_rate &amp; accuracy as a list for the metrics parameter specifying we want to see both error_rate and accuracy, and finally specify a weight decay of 1e-1 (1.0). | learn.lr_find() &amp; learn.recorder.plot() function to run LR Finder. LR Finder help to find the best learning rate to use with our network. For more information the original paper. As shown from the output of above. . | learn.recorder.plot() function plot the loss over learning rate. Run the following code block to view the graph. The best learning rate should be chosen as the learning rate value where the curve is the steepest. You may try different learning rate values in order to pick up the best. . | [learn.fit_one_cycle() &amp; learn.recorder.plot_losses()] The learn.fit_one_cycle() function can be used to fit the model. Fit one cycle reach a comparable accuracy faster than th fit function in training of complex models. Fit one cycle instead of maintain fix the learning rate during all the iterations is linearly increasing the learning rate and then it is decreasing again (this process is what is called one cycle). Moreover, this learning rate variation is helping in preventing overfitting. We use 5 for the parameter cyc_len to specify the number of cycles to run (on cycle can be considered equivalent to an epoch), and max_lr to specify the maximum learning rate to use which we set as 0.001. Fit one cycle varies the learning rate from 10 fold less the maximum learning rate selected. For more information about fit one cycle: article. . | . | Testing with Deeper Architectures . learn = cnn_learner(dls, resnet101, loss_func=CrossEntropyLossFlat(), metrics=[error_rate,accuracy], wd=1e-1).to_fp16() . learn.cbs . (#4) [TrainEvalCallback,Recorder,ProgressCallback,MixedPrecision] . We apply a very powerful Data Augmentation technique that is Mixup and train the model. . learn.fit_one_cycle(80, 3e-3, cbs=MixUp(0.5)) . . epoch train_loss valid_loss error_rate accuracy time . 0 | 1.098607 | 0.923316 | 0.405242 | 0.594758 | 00:23 | . 1 | 0.959609 | 0.496383 | 0.227823 | 0.772177 | 00:23 | . 2 | 0.907947 | 0.482087 | 0.223790 | 0.776210 | 00:23 | . 3 | 0.874337 | 0.519458 | 0.252016 | 0.747984 | 00:22 | . 4 | 0.838613 | 0.474054 | 0.221774 | 0.778226 | 00:23 | . 5 | 0.800547 | 0.362412 | 0.159274 | 0.840726 | 00:23 | . 6 | 0.766916 | 0.340699 | 0.137097 | 0.862903 | 00:23 | . 7 | 0.732544 | 0.190343 | 0.060484 | 0.939516 | 00:23 | . 8 | 0.705716 | 0.234552 | 0.092742 | 0.907258 | 00:22 | . 9 | 0.672490 | 0.225245 | 0.092742 | 0.907258 | 00:23 | . 10 | 0.646345 | 0.196367 | 0.082661 | 0.917339 | 00:23 | . 11 | 0.614197 | 0.207071 | 0.082661 | 0.917339 | 00:22 | . 12 | 0.580931 | 0.145530 | 0.058468 | 0.941532 | 00:22 | . 13 | 0.551455 | 0.160765 | 0.062500 | 0.937500 | 00:22 | . 14 | 0.530735 | 0.156187 | 0.058468 | 0.941532 | 00:22 | . 15 | 0.508143 | 0.133556 | 0.040323 | 0.959677 | 00:23 | . 16 | 0.486114 | 0.130424 | 0.048387 | 0.951613 | 00:23 | . 17 | 0.468766 | 0.112146 | 0.036290 | 0.963710 | 00:23 | . 18 | 0.451705 | 0.106726 | 0.038306 | 0.961694 | 00:23 | . 19 | 0.435460 | 0.140806 | 0.046371 | 0.953629 | 00:23 | . 20 | 0.421944 | 0.129412 | 0.042339 | 0.957661 | 00:23 | . 21 | 0.409734 | 0.107145 | 0.034274 | 0.965726 | 00:23 | . 22 | 0.399341 | 0.125089 | 0.042339 | 0.957661 | 00:23 | . 23 | 0.389513 | 0.099228 | 0.036290 | 0.963710 | 00:23 | . 24 | 0.380188 | 0.082548 | 0.018145 | 0.981855 | 00:23 | . 25 | 0.370885 | 0.071890 | 0.016129 | 0.983871 | 00:23 | . 26 | 0.363348 | 0.126151 | 0.044355 | 0.955645 | 00:23 | . 27 | 0.356708 | 0.085095 | 0.022177 | 0.977823 | 00:23 | . 28 | 0.351457 | 0.082022 | 0.030242 | 0.969758 | 00:23 | . 29 | 0.346920 | 0.082360 | 0.022177 | 0.977823 | 00:23 | . 30 | 0.343117 | 0.086793 | 0.026210 | 0.973790 | 00:23 | . 31 | 0.338743 | 0.084433 | 0.028226 | 0.971774 | 00:23 | . 32 | 0.332180 | 0.050694 | 0.012097 | 0.987903 | 00:23 | . 33 | 0.329243 | 0.075656 | 0.022177 | 0.977823 | 00:23 | . 34 | 0.325888 | 0.074826 | 0.018145 | 0.981855 | 00:22 | . 35 | 0.321171 | 0.051103 | 0.016129 | 0.983871 | 00:22 | . 36 | 0.317992 | 0.068456 | 0.014113 | 0.985887 | 00:23 | . 37 | 0.317117 | 0.095658 | 0.038306 | 0.961694 | 00:23 | . 38 | 0.314691 | 0.075247 | 0.026210 | 0.973790 | 00:23 | . 39 | 0.312669 | 0.059977 | 0.014113 | 0.985887 | 00:23 | . 40 | 0.311207 | 0.062207 | 0.016129 | 0.983871 | 00:23 | . 41 | 0.307136 | 0.079891 | 0.032258 | 0.967742 | 00:23 | . 42 | 0.303215 | 0.060350 | 0.014113 | 0.985887 | 00:23 | . 43 | 0.301979 | 0.061862 | 0.014113 | 0.985887 | 00:23 | . 44 | 0.302073 | 0.056083 | 0.012097 | 0.987903 | 00:23 | . 45 | 0.298332 | 0.054264 | 0.014113 | 0.985887 | 00:23 | . 46 | 0.297571 | 0.050670 | 0.006048 | 0.993952 | 00:23 | . 47 | 0.295835 | 0.053044 | 0.014113 | 0.985887 | 00:23 | . 48 | 0.295003 | 0.053177 | 0.006048 | 0.993952 | 00:23 | . 49 | 0.295658 | 0.070317 | 0.012097 | 0.987903 | 00:23 | . 50 | 0.293548 | 0.051080 | 0.008064 | 0.991935 | 00:23 | . 51 | 0.293651 | 0.061804 | 0.016129 | 0.983871 | 00:23 | . 52 | 0.291592 | 0.044012 | 0.010081 | 0.989919 | 00:23 | . 53 | 0.289374 | 0.047382 | 0.006048 | 0.993952 | 00:23 | . 54 | 0.288036 | 0.050668 | 0.006048 | 0.993952 | 00:23 | . 55 | 0.286396 | 0.057323 | 0.016129 | 0.983871 | 00:23 | . 56 | 0.285277 | 0.049304 | 0.012097 | 0.987903 | 00:23 | . 57 | 0.283157 | 0.047652 | 0.010081 | 0.989919 | 00:23 | . 58 | 0.282250 | 0.046741 | 0.008064 | 0.991935 | 00:23 | . 59 | 0.282024 | 0.043001 | 0.006048 | 0.993952 | 00:23 | . 60 | 0.281422 | 0.043425 | 0.004032 | 0.995968 | 00:22 | . 61 | 0.279792 | 0.048245 | 0.004032 | 0.995968 | 00:23 | . 62 | 0.278259 | 0.050301 | 0.008064 | 0.991935 | 00:23 | . 63 | 0.276450 | 0.042498 | 0.006048 | 0.993952 | 00:23 | . 64 | 0.275557 | 0.043382 | 0.008064 | 0.991935 | 00:23 | . 65 | 0.274992 | 0.046327 | 0.008064 | 0.991935 | 00:23 | . 66 | 0.274949 | 0.051264 | 0.012097 | 0.987903 | 00:23 | . 67 | 0.276006 | 0.050355 | 0.010081 | 0.989919 | 00:23 | . 68 | 0.277512 | 0.047513 | 0.008064 | 0.991935 | 00:22 | . 69 | 0.275122 | 0.044733 | 0.006048 | 0.993952 | 00:22 | . 70 | 0.275745 | 0.042205 | 0.006048 | 0.993952 | 00:23 | . 71 | 0.274163 | 0.041508 | 0.006048 | 0.993952 | 00:23 | . 72 | 0.273943 | 0.042359 | 0.006048 | 0.993952 | 00:23 | . 73 | 0.273899 | 0.042546 | 0.006048 | 0.993952 | 00:23 | . 74 | 0.271843 | 0.044013 | 0.006048 | 0.993952 | 00:23 | . 75 | 0.271735 | 0.043344 | 0.006048 | 0.993952 | 00:22 | . 76 | 0.271392 | 0.045417 | 0.008064 | 0.991935 | 00:23 | . 77 | 0.270836 | 0.044158 | 0.006048 | 0.993952 | 00:23 | . 78 | 0.272595 | 0.043604 | 0.008064 | 0.991935 | 00:23 | . 79 | 0.272234 | 0.044281 | 0.008064 | 0.991935 | 00:23 | . TTA(Test Time Augmentation) . preds,targs = learn.tta() # TTA applied for validation dataset accuracy(preds, targs).item() . . . 0.9959677457809448 . We get a TTA of 99.59% on the validation set. . ClassificationInterpretationEx . We examine the model predictions in more depth: . import fastai def _get_truths(vocab, label_idx, is_multilabel): if is_multilabel: return &#39;;&#39;.join([vocab[i] for i in torch.where(label_idx==1)][0]) else: return vocab[label_idx] class ClassificationInterpretationEx(ClassificationInterpretation): &quot;&quot;&quot; Extend fastai2&#39;s `ClassificationInterpretation` to analyse model predictions in more depth See: * self.preds_df * self.plot_label_confidence() * self.plot_confusion_matrix() * self.plot_accuracy() * self.get_fnames() * self.plot_top_losses_grid() * self.print_classification_report() &quot;&quot;&quot; def __init__(self, dl, inputs, preds, targs, decoded, losses): super().__init__(dl, inputs, preds, targs, decoded, losses) self.vocab = self.dl.vocab if is_listy(self.vocab): self.vocab = self.vocab[-1] if self.targs.__class__ == fastai.torch_core.TensorMultiCategory: self.is_multilabel = True else: self.is_multilabel = False self.compute_label_confidence() self.determine_classifier_type() def determine_classifier_type(self): if self.targs[0].__class__==fastai.torch_core.TensorCategory: self.is_multilabel = False if self.targs[0].__class__==fastai.torch_core.TensorMultiCategory: self.is_multilabel = True self.thresh = self.dl.loss_func.thresh def compute_label_confidence(self, df_colname:Optional[str]=&quot;fnames&quot;): &quot;&quot;&quot; Collate prediction confidence, filenames, and ground truth labels in DataFrames, and store them as class attributes `self.preds_df` and `self.preds_df_each` If the `DataLoaders` is constructed from a `pd.DataFrame`, use `df_colname` to specify the column name with the filepaths &quot;&quot;&quot; if not isinstance(self.dl.items, pd.DataFrame): self._preds_collated = [ #(item, self.dl.vocab[label_idx], *preds.numpy()*100) (item, _get_truths(self.dl.vocab, label_idx, self.is_multilabel), *preds.numpy()*100) for item,label_idx,preds in zip(self.dl.items, self.targs, self.preds) ] ## need to extract fname from DataFrame elif isinstance(self.dl.items, pd.DataFrame): self._preds_collated = [ #(item[df_colname], self.dl.vocab[label_idx], *preds.numpy()*100) (item[df_colname], _get_truths(self.dl.vocab, label_idx, self.is_multilabel), *preds.numpy()*100) for (_,item),label_idx,preds in zip(self.dl.items.iterrows(), self.targs, self.preds) ] self.preds_df = pd.DataFrame(self._preds_collated, columns = [&#39;fname&#39;,&#39;truth&#39;, *self.dl.vocab]) self.preds_df.insert(2, column=&#39;loss&#39;, value=self.losses.numpy()) if self.is_multilabel: return # preds_df_each doesnt make sense for multi-label self._preds_df_each = {l:self.preds_df.copy()[self.preds_df.truth == l].reset_index(drop=True) for l in self.dl.vocab} self.preds_df_each = defaultdict(dict) sort_desc = lambda x,col: x.sort_values(col, ascending=False).reset_index(drop=True) for label,df in self._preds_df_each.items(): filt = df[label] == df[self.dl.vocab].max(axis=1) self.preds_df_each[label][&#39;accurate&#39;] = df.copy()[filt] self.preds_df_each[label][&#39;inaccurate&#39;] = df.copy()[~filt] self.preds_df_each[label][&#39;accurate&#39;] = sort_desc(self.preds_df_each[label][&#39;accurate&#39;], label) self.preds_df_each[label][&#39;inaccurate&#39;] = sort_desc(self.preds_df_each[label][&#39;inaccurate&#39;], label) assert len(self.preds_df_each[label][&#39;accurate&#39;]) + len(self.preds_df_each[label][&#39;inaccurate&#39;]) == len(df) def get_fnames(self, label:str, mode:(&#39;accurate&#39;,&#39;inaccurate&#39;), conf_level:Union[int,float,tuple]) -&gt; np.ndarray: &quot;&quot;&quot; Utility function to grab filenames of a particular label `label` that were classified as per `mode` (accurate|inaccurate). These filenames are filtered by `conf_level` which can be above or below a certain threshold (above if `mode` == &#39;accurate&#39; else below), or in confidence ranges &quot;&quot;&quot; assert label in self.dl.vocab if not hasattr(self, &#39;preds_df_each&#39;): self.compute_label_confidence() df = self.preds_df_each[label][mode].copy() if mode == &#39;accurate&#39;: if isinstance(conf_level, tuple): filt = df[label].between(*conf_level) if isinstance(conf_level, (int,float)): filt = df[label] &gt; conf_level if mode == &#39;inaccurate&#39;: if isinstance(conf_level, tuple): filt = df[label].between(*conf_level) if isinstance(conf_level, (int,float)): filt = df[label] &lt; conf_level return df[filt].fname.values . . fname truth loss COVID non-COVID . 0 sarscov2-ctscan-dataset/non-COVID/Non-Covid (386).png | non-COVID | 0.047037 | 4.594821 | 95.405182 | . 1 sarscov2-ctscan-dataset/COVID/Covid (581).png | COVID | 0.018380 | 98.178818 | 1.821182 | . ClassificationInterpretationEx.get_fnames . Returns accuratly classified files with accuracy above 85%: . interp.get_fnames(&#39;accurate&#39;, 99.95) . . Returns inaccurately classified files with accuracy between 84.1-85.2%: . interp.get_fnames(&#39;img1&#39;, &#39;accurate&#39;, (84.1, 85.2)) . . Confusion Matrix . Checking the Confusion Matrix: . Plot Accuracy . plotting curves of training process: . functions to plot the accuracy of the labels: . @patch def plot_accuracy(self:ClassificationInterpretationEx, width=0.9, figsize=(6,6), return_fig=False, title=&#39;Accuracy Per Label&#39;, ylabel=&#39;Accuracy (%)&#39;, style=&#39;ggplot&#39;, color=&#39;#2a467e&#39;, vertical_labels=True): &#39;Plot a bar plot showing accuracy per label&#39; if not hasattr(self, &#39;preds_df_each&#39;): raise NotImplementedError plt.style.use(style) if not hasattr(self, &#39;preds_df_each&#39;): self.compute_label_confidence() self.accuracy_dict = defaultdict() for label,df in self.preds_df_each.items(): total = len(df[&#39;accurate&#39;]) + len(df[&#39;inaccurate&#39;]) self.accuracy_dict[label] = 100 * len(df[&#39;accurate&#39;]) / total fig,ax = plt.subplots(figsize=figsize) x = self.accuracy_dict.keys() y = [v for k,v in self.accuracy_dict.items()] rects = ax.bar(x,y,width,color=color) for rect in rects: ht = rect.get_height() ax.annotate(s = f&quot;{ht:.02f}&quot;, xy = (rect.get_x() + rect.get_width()/2, ht), xytext = (0,3), # offset vertically by 3 points textcoords = &#39;offset points&#39;, ha = &#39;center&#39;, va = &#39;bottom&#39; ) ax.set_ybound(lower=0, upper=100) ax.set_yticks(np.arange(0,110,10)) ax.set_ylabel(ylabel) ax.set_xticklabels(x, rotation=&#39;vertical&#39; if vertical_labels else &#39;horizontal&#39;) plt.suptitle(title) plt.tight_layout() if return_fig: return fig . . &lt;ipython-input-67-2c6afab5379f&gt;:25: MatplotlibDeprecationWarning: The &#39;s&#39; parameter of annotate() has been renamed &#39;text&#39; since Matplotlib 3.3; support for the old name will be dropped two minor releases later. ax.annotate(s = f&#34;{ht:.02f}&#34;, &lt;ipython-input-67-2c6afab5379f&gt;:34: UserWarning: FixedFormatter should only be used together with FixedLocator ax.set_xticklabels(x, rotation=&#39;vertical&#39; if vertical_labels else &#39;horizontal&#39;) . Plot Label Confidence . Plotting label confidence as histograms for each label: . @patch def plot_label_confidence(self:ClassificationInterpretationEx, bins:int=5, fig_width:int=12, fig_height_base:int=4, title:str=&#39;Accurate vs. Inaccurate Predictions Confidence (%) Levels Per Label&#39;, return_fig:bool=False, label_bars:bool=True, style=&#39;ggplot&#39;, dpi=150, accurate_color=&#39;#2a467e&#39;, inaccurate_color=&#39;#dc4a46&#39;): &quot;&quot;&quot;Plot label confidence histograms for each label Key Args: * `bins`: No. of bins on each side of the plot * `return_fig`: If True, returns the figure that can be easily saved to disk * `label_bars`: If True, displays the % of samples that fall into each bar * `style`: A matplotlib style. See `plt.style.available` for more * `accurate_color`: Color of the accurate bars * `inaccurate_color`: Color of the inaccurate bars &quot;&quot;&quot; if not hasattr(self, &#39;preds_df_each&#39;): raise NotImplementedError plt.style.use(style) fig, axes = plt.subplots(nrows = len(self.preds_df_each.keys()), ncols=2, dpi=dpi, figsize = (fig_width, fig_height_base * len(self.dl.vocab))) for i, (label, df) in enumerate(self.preds_df_each.items()): height=0 # find max height for mode in [&#39;inaccurate&#39;, &#39;accurate&#39;]: len_bins,_ = np.histogram(df[mode][label], bins=bins) if len_bins.max() &gt; height: height=len_bins.max() for mode,ax in zip([&#39;inaccurate&#39;, &#39;accurate&#39;], axes[i]): range_ = (50,100) if mode == &#39;accurate&#39; else (0,50) color = accurate_color if mode == &#39;accurate&#39; else inaccurate_color num,_,patches = ax.hist(df[mode][label], bins=bins, range=range_, rwidth=.95, color=color) num_samples = len(df[&#39;inaccurate&#39;][label]) + len(df[&#39;accurate&#39;][label]) pct_share = len(df[mode][label]) / num_samples if label_bars: for rect in patches: ht = rect.get_height() ax.annotate(s = f&quot;{round((int(ht) / num_samples) * 100, 1) if ht &gt; 0 else 0}%&quot;, xy = (rect.get_x() + rect.get_width()/2, ht), xytext = (0,3), # offset vertically by 3 points textcoords = &#39;offset points&#39;, ha = &#39;center&#39;, va = &#39;bottom&#39; ) ax.set_ybound(upper=height + height*0.3) ax.set_xlabel(f&#39;{label}: {mode.capitalize()} ({round(pct_share * 100, 2)}%)&#39;) ax.set_ylabel(f&#39;Num. {mode.capitalize()} ({len(df[mode][label])} of {num_samples})&#39;) fig.suptitle(title, y=1.0) plt.subplots_adjust(top = 0.9, bottom=0.01, hspace=0.25, wspace=0.2) plt.tight_layout() if return_fig: return fig . . &lt;ipython-input-69-1241d4a5b1b6&gt;:37: MatplotlibDeprecationWarning: The &#39;s&#39; parameter of annotate() has been renamed &#39;text&#39; since Matplotlib 3.3; support for the old name will be dropped two minor releases later. ax.annotate(s = f&#34;{round((int(ht) / num_samples) * 100, 1) if ht &gt; 0 else 0}%&#34;, . Plot Top Losses grid . plotting the top losses in a grid: . from fastai_amalgam.utils import * @patch def plot_top_losses_grid(self:ClassificationInterpretationEx, k=16, ncol=4, __largest=True, font_path=None, font_size=12, use_dedicated_layout=True) -&gt; PIL.Image.Image: &quot;&quot;&quot;Plot top losses in a grid Uses fastai&#39;a `ClassificationInterpretation.plot_top_losses` to fetch predictions, and makes a grid with the ground truth labels, predictions, prediction confidence and loss ingrained into the image By default, `use_dedicated_layout` is used to plot the loss (bottom), truths (top-left), and predictions (top-right) in dedicated areas of the image. If this is set to `False`, everything is printed at the bottom of the image &quot;&quot;&quot; # all of the pred fetching code is copied over from # fastai&#39;s `ClassificationInterpretation.plot_top_losses` # and only plotting code is added here losses,idx = self.top_losses(k, largest=__largest) if not isinstance(self.inputs, tuple): self.inputs = (self.inputs,) if isinstance(self.inputs[0], Tensor): inps = tuple(o[idx] for o in self.inputs) else: inps = self.dl.create_batch(self.dl.before_batch([tuple(o[i] for o in self.inputs) for i in idx])) b = inps + tuple(o[idx] for o in (self.targs if is_listy(self.targs) else (self.targs,))) x,y,its = self.dl._pre_show_batch(b, max_n=k) b_out = inps + tuple(o[idx] for o in (self.decoded if is_listy(self.decoded) else (self.decoded,))) x1,y1,outs = self.dl._pre_show_batch(b_out, max_n=k) #if its is not None: # _plot_top_losses(x, y, its, outs.itemgot(slice(len(inps), None)), self.preds[idx], losses, **kwargs) plot_items = its.itemgot(0), its.itemgot(1), outs.itemgot(slice(len(inps), None)), self.preds[idx], losses def draw_label(x:TensorImage, labels): return PILImage.create(x).draw_labels(labels, font_path=font_path, font_size=font_size, location=&quot;bottom&quot;) # return plot_items results = [] for x, truth, preds, preds_raw, loss in zip(*plot_items): if self.is_multilabel: preds = preds[0] probs_i = np.array([self.dl.vocab.o2i[o] for o in preds]) pred2prob = [f&quot;{pred} ({round(prob.item()*100,2)}%)&quot; for pred,prob in zip(preds,preds_raw[probs_i])] if use_dedicated_layout: # draw loss at the bottom, preds on top-right # and truths on the top img = PILImage.create(x) if isinstance(truth, Category): truth = [truth] truth.insert(0, &quot;TRUTH: &quot;) pred2prob.insert(0, &#39;PREDS: &#39;) loss_text = f&quot;{&#39;LOSS: &#39;.rjust(8)} {round(loss.item(), 4)}&quot; img.draw_labels(truth, location=&quot;top-left&quot;, font_size=font_size, font_path=font_path) img.draw_labels(pred2prob, location=&quot;top-right&quot;, font_size=font_size, font_path=font_path) img.draw_labels(loss_text, location=&quot;bottom&quot;, font_size=font_size, font_path=font_path) results.append(img) else: # draw everything at the bottom out = [] out.append(f&quot;{&#39;TRUTH: &#39;.rjust(8)} {truth}&quot;) bsl = &#39; n&#39; # since f-strings can&#39;t have backslashes out.append(f&quot;{&#39;PRED: &#39;.rjust(8)} {bsl.join(pred2prob)}&quot;) if self.is_multilabel: out.append(&#39; n&#39;) out.append(f&quot;{&#39;LOSS: &#39;.rjust(8)} {round(loss.item(), 4)}&quot;) results.append(draw_label(x, out)) return make_img_grid(results, img_size=None, ncol=ncol) . . /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai_amalgam/utils.py:92: UserWarning: Loaded default PIL ImageFont. It&#39;s highly recommended you use a custom font as the default font&#39;s size cannot be tweaked warnings.warn(&#34;Loaded default PIL ImageFont. It&#39;s highly recommended you use a custom font as the default font&#39;s size cannot be tweaked&#34;) /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai_amalgam/utils.py:94: UserWarning: `font_size` cannot be used when not using a custom font passed via `font_path` warnings.warn(f&#34;`font_size` cannot be used when not using a custom font passed via `font_path`&#34;) . PlotLowest Losses Grid . plotting the lowest losses in a grid fashion: . @patch @delegates(to=ClassificationInterpretationEx.plot_top_losses_grid, but=[&#39;largest&#39;]) def plot_lowest_losses_grid(self:ClassificationInterpretationEx, **kwargs): &quot;&quot;&quot;Plot the lowest losses. Exact opposite of `ClassificationInterpretationEx.plot_top_losses` &quot;&quot;&quot; return self.plot_top_losses_grid(__largest=False, **kwargs) . . Classification Report . scikit-learn Classification report: . import sklearn.metrics as skm @patch def print_classification_report(self:ClassificationInterpretationEx, as_dict=False): &quot;Get scikit-learn classification report&quot; # `flatten_check` and `skm.classification_report` don&#39;t play # nice together for multi-label # d,t = flatten_check(self.decoded, self.targs) d,t = self.decoded, self.targs if as_dict: return skm.classification_report(t, d, labels=list(self.vocab.o2i.values()), target_names=[str(v) for v in self.vocab], output_dict=True) else: return skm.classification_report(t, d, labels=list(self.vocab.o2i.values()), target_names=[str(v) for v in self.vocab], output_dict=False) . . precision recall f1-score support COVID 0.99 0.98 0.99 243 non-COVID 0.98 0.99 0.99 253 accuracy 0.99 496 macro avg 0.99 0.99 0.99 496 weighted avg 0.99 0.99 0.99 496 . TTA (Test Time Augmentation) . Getting the TTA Score on the validation set: . . 0.9939516186714172 . Checking the confusion matrix: . Exporting the learner into a pickle file: . learn.export() . . (#1) [Path(&#39;export.pkl&#39;)] . Resnet-50 Test . We train with smaller images of sizes 128*128 rather than orignal size of the image and also smaller batch sizes for faster training. . dls2=get_dls(128,128) . learn2 = cnn_learner(dls2, xresnet50, metrics=[error_rate,accuracy], wd=1e-1).to_fp16() . . Running the l.r Finder: . print(f&quot;Minimum/10: {lr_min:.2e}, steepest point: {lr_steep:.2e}&quot;) . . Minimum/10: 8.32e-03, steepest point: 3.31e-04 . Training the model in first run: . learn2.fit_one_cycle(5, 3e-3) . epoch train_loss valid_loss error_rate accuracy time . 0 | 0.825077 | 2.717013 | 0.504032 | 0.495968 | 00:09 | . 1 | 0.637306 | 0.874084 | 0.328629 | 0.671371 | 00:09 | . 2 | 0.538363 | 0.493991 | 0.203629 | 0.796371 | 00:09 | . 3 | 0.473004 | 0.253523 | 0.122984 | 0.877016 | 00:09 | . 4 | 0.427544 | 0.230788 | 0.098790 | 0.901210 | 00:09 | . plotting the curves of training process: . Unfreezing the model and then running l.r finder again for getting the optimal l.r rate (FineTuneing Approach): . SuggestedLRs(lr_min=6.309573450380412e-08, lr_steep=2.75422871709452e-06) . print(f&quot;Minimum/10: {lr_min:.2e}, steepest point: {lr_steep:.2e}&quot;) . . Minimum/10: 8.32e-03, steepest point: 3.31e-04 . learn2.dls2 = get_dls(12, 224)# training on orignal size learn2.fit_one_cycle( 12, slice(1e-5, 1e-4)) . epoch train_loss valid_loss error_rate accuracy time . 0 | 0.326667 | 0.237666 | 0.106855 | 0.893145 | 00:10 | . 1 | 0.314330 | 0.248609 | 0.110887 | 0.889113 | 00:10 | . 2 | 0.306127 | 0.233944 | 0.090726 | 0.909274 | 00:10 | . 3 | 0.306658 | 0.229167 | 0.094758 | 0.905242 | 00:10 | . 4 | 0.305483 | 0.281535 | 0.125000 | 0.875000 | 00:10 | . 5 | 0.293949 | 0.245766 | 0.102823 | 0.897177 | 00:10 | . 6 | 0.290125 | 0.226233 | 0.102823 | 0.897177 | 00:10 | . 7 | 0.279198 | 0.230645 | 0.110887 | 0.889113 | 00:10 | . 8 | 0.271748 | 0.244468 | 0.110887 | 0.889113 | 00:10 | . 9 | 0.270165 | 0.208932 | 0.086694 | 0.913306 | 00:10 | . 10 | 0.268667 | 0.208460 | 0.084677 | 0.915323 | 00:10 | . 11 | 0.264588 | 0.216885 | 0.096774 | 0.903226 | 00:10 | . Checking the curves again: . Checking the Confusion Matrix: . interp = ClassificationInterpretation.from_learner(learn2)# plot confusion matrix interp.plot_confusion_matrix(figsize=(12,12), dpi=50) . . Plotting top losses . learn2.save(&#39;resnet50run&#39;) . Path(&#39;models/resnet50run.pth&#39;) . learn2=learn2.load(&#39;resnet50run&#39;) . end test . interp = ClassificationInterpretation.from_learner(learn)# plot confusion matrix interp.plot_confusion_matrix(figsize=(12,12), dpi=50) . . interp.plot_top_losses(5, nrows=10)# plot top losses . . learn1=load_learner(&quot;export.pkl&quot;) . GradCam Testing . Steps for plotting GradCAM: . Create your Learner&#39;s test_dl w.r.t. one image and label-Compute activations (forward pass) and gradients (backward pass) | Compute gradcam-map (7x7 in this case) | Take mean of gradients across feature maps: (1280, 7, 7) --&gt; (1280, 1, 1) | Multiply mean activation: (1280,1,1) (1280,7,7) --&gt; (1280,7,7) | Sum (B) across all 1280 channels: (1280,7,7) --&gt; (7,7) | Plot gradcam-map over the image | These steps are shown below one by one and later combined in a Learner.gradcam call | 1. Create Learner&#39;s test_dl w.r.t. one image and label . def create_test_img(learn, f, return_img=True): img = PILImage.create(f) x = first(learn.dls.test_dl([f])) x = x[0] if return_img: return img,x return x . 2. Compute activations (forward pass) and gradients (backward pass) . def get_label_idx(learn:Learner, preds:torch.Tensor, label:Union[str,int,None]) -&gt; Tuple[int,str]: &quot;&quot;&quot;Either: * Get the label idx of a specific `label` * Get the max pred using `learn.loss_func.decode` and `learn.loss_func.activation` * Only works for `softmax` activations as the backward pass requires a scalar index * Throws a `RuntimeError` if the activation is a `sigmoid` activation &quot;&quot;&quot; if label is not None: # if `label` is a string, check that it exists in the vocab # and return the label&#39;s index if isinstance(label,str): if not label in learn.dls.vocab: raise ValueError(f&quot;&#39;{label}&#39; is not part of the Learner&#39;s vocab: {learn.dls.vocab}&quot;) return learn.dls.vocab.o2i[label], label # if `label` is an index, return itself elif isinstance(label,int): return label, learn.dls.vocab[label] else: raise TypeError(f&quot;Expected `str`, `int` or `None`, got {type(label)} instead&quot;) else: # if no `label` is specified, check that `learn.loss_func` has `decodes` # and `activation` implemented, run the predictions through them, # then check that the output length is 1. If not, the activation must be # sigmoid, which is incompatible if not hasattr(learn.loss_func, &#39;activation&#39;) or not hasattr(learn.loss_func, &#39;decodes&#39;): raise NotImplementedError(f&quot;learn.loss_func does not have `.activation` or `.decodes` methods implemented&quot;) decode_pred = compose(learn.loss_func.activation, learn.loss_func.decodes) label_idx = decode_pred(preds) if len(label_idx) &gt; 1: raise RuntimeError(f&quot;Output label idx must be of length==1. If your loss func has a sigmoid activation, please specify `label`&quot;) return label_idx, learn.dls.vocab[label_idx][0] . . def compute_gcam_items(learn: Learner, x: TensorImage, label: Union[str,int,None] = None, target_layer: Union[nn.Module, Callable, None] = None ) -&gt; Tuple[torch.Tensor]: &quot;&quot;&quot;Compute gradient and activations of `target_layer` of `learn.model` for `x` with respect to `label`. If `target_layer` is None, then it is set to `learn.model[:-1]` &quot;&quot;&quot; to_cuda(learn.model, x) target_layer = get_target_layer(learn, target_layer) with HookBwd(target_layer) as hook_g: with Hook(target_layer) as hook: preds = learn.model.eval()(x) activations = hook.stored label_idx, label = get_label_idx(learn,preds,label) #print(preds.shape, label, label_idx) #print(preds) preds[0, label_idx].backward() gradients = hook_g.stored preds = getattr(learn.loss_func, &#39;activation&#39;, noop)(preds) # remove the leading batch_size axis gradients = gradients [0] activations = activations[0] preds = preds.detach().cpu().numpy().flatten() return gradients, activations, preds, label . . shapes of gradients, activations and predictions: . &lt;ipython-input-137-c549b6a525cc&gt;:6: UserWarning: Detected a pooling layer in the model body. Unless this is intentional, ensure that the feature map is not flattened warnings.warn(f&#34;Detected a pooling layer in the model body. Unless this is intentional, ensure that the feature map is not flattened&#34;) . (torch.Size([2048, 7, 7]), torch.Size([2048, 7, 7]), (2,), &#39;COVID&#39;) . 3. Compute gradcam-map . def compute_gcam_map(gradients, activations) -&gt; torch.Tensor: &quot;&quot;&quot;Take the mean of `gradients`, multiply by `activations`, sum it up and return a GradCAM feature map &quot;&quot;&quot; # Mean over the feature maps. If you don&#39;t use `keepdim`, it returns # a value of shape (1280) which isn&#39;t amenable to `*` with the activations gcam_weights = gradients.mean(dim=[1,2], keepdim=True) # (1280,7,7) --&gt; (1280,1,1) gcam_map = (gcam_weights * activations) # (1280,1,1) * (1280,7,7) --&gt; (1280,7,7) gcam_map = gcam_map.sum(0) # (1280,7,7) --&gt; (7,7) return gcam_map . . gcam_map = compute_gcam_map(gradients, activations) gcam_map.shape . torch.Size([7, 7]) . 4. Plot gradcam-map over the image . plotting Grad Cam over image . plot_gcam(learn, img3, x, gcam_map, full_size=True, dpi=300) . . learn.model[1] . . Sequential( (0): AdaptiveConcatPool2d( (ap): AdaptiveAvgPool2d(output_size=1) (mp): AdaptiveMaxPool2d(output_size=1) ) (1): Flatten(full=False) (2): BatchNorm1d(4096, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): Dropout(p=0.25, inplace=False) (4): Linear(in_features=4096, out_features=512, bias=False) (5): ReLU(inplace=True) (6): BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (7): Dropout(p=0.5, inplace=False) (8): Linear(in_features=512, out_features=2, bias=False) ) . learn.gradcam(item=im, target_layer=learn.model[0]) . . /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai_amalgam/utils.py:92: UserWarning: Loaded default PIL ImageFont. It&#39;s highly recommended you use a custom font as the default font&#39;s size cannot be tweaked warnings.warn(&#34;Loaded default PIL ImageFont. It&#39;s highly recommended you use a custom font as the default font&#39;s size cannot be tweaked&#34;) . GUI Building . Creating Buttons: . btn_upload = widgets.FileUpload() btn_upload . img= PILImage.create(btn_upload.data[-1]) . img.shape . (350, 408) . out_pl = widgets.Output() out_pl.clear_output() with out_pl: display(img.to_thumb(384,404)) out_pl . dls.vocab . [&#39;COVID&#39;, &#39;non-COVID&#39;] . pred,pred_idx,probs = learn.predict(img) . lbl_pred = widgets.Label() lbl_pred.value = f&#39;Prediction: {pred}; Probability: {probs[pred_idx]:.04f}&#39; lbl_pred . btn_run = widgets.Button(description=&#39;Classify&#39;,layout=Layout(width=&#39;40%&#39;, height=&#39;80px&#39;), button_style=&#39;success&#39;) btn_run . Click event handler adds functionallity to butttons: . def on_click_classify(change): img = PILImage.create(btn_upload.data[-1]) out_pl.clear_output() with out_pl: display(img.to_thumb(320,320)) pred,pred_idx,probs = learn_inf.predict(img) lbl_pred.value = f&#39;Prediction: {pred}; Probability: {probs[pred_idx]:.04f}&#39; btn_run.on_click(on_click_classify) . Adding heatmaps button and functionallity: . HeatMp = widgets.Button(description=&#39;MAGIC&#39;, layout=btn_run.layout, button_style=&#39;danger&#39;) HeatMp . def on_click_map(change): with out_pl: display(img.to_thumb(320,320)) learn.gradcam(img).clear(out_pl) HeatMp.on_click(on_click_map) . Putting all the pieces together in a Vertical Stack for the final GUI: . VBox([widgets.Label(&#39;INPUT YOUR CT SCAN IMAGE FOR DETECTION!&#39;), btn_upload, btn_run, out_pl, lbl_pred,widgets.Label(&#39;Do You Want to See How our Model Decides which is Covid and Which is not?&#39;),widgets.Label(&quot;Click Here To Learn how These predictions are made&quot;), HeatMp]) . If You want to see the GUI that I built for this Project check out my other blog post named: Covify . What Worked? . Using a pretrained model Resnet reduced training time and improved results. | Data Augmentations reduced overfitting. | The Mixup approach worked like a charm and also prevented overfitting. | Presizing approaches worked. | I tried Progressive Resizing approach and it greatly improved results and reduced training time. | . What didn&#39;t? . I tried implementing bottleneck layers design on resnets but training was unstable. | I tried a deeper vanilla Resnet 101 model but did not noticed a a significant difference. | . Other ideas to improve the results? . Trying with Diffrent Architectures like Densenet, Efficient Net etc. | Trying out diffrent metrics and improving on them for better results. | More Compute: Deeper Models. Use cross-validation with several folds and Ensemble models. | . Thank you for reading this far!😊This was a great challenge and I learned a lot throughout this process.There is also a lot of room for improvement and work to do :) .",
            "url": "https://priyank7n.me/2021/01/23/covify-code.html",
            "relUrl": "/2021/01/23/covify-code.html",
            "date": " • Jan 23, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Covify",
            "content": "About . GUI and its Functionalities are: . We can upload a CT Scan Image, and our model Covify will predict whether the image uploaded is of a Covid Infected person or not. | When we click the Classify button, the model gives a softmax probability of the decision is made and how strongly it tries to put forward its integrity. | When we click on the Magic Button, it shows a heat map of all the activations in the image that influenced the model to make certain decisions. | . Covid Prediction on CT Scan Images . Non-Covid Prediction on CT Scan Images . When we click on CT Scan images, Our Model predicts whether it is covid or not and shows a heat map demonstrating the basis of the model&#39;s predictions . Heatmaps . This is a heat map for the image showcasing which activations or parts of the image led the model to predict certain decisions on whether the person is covid or not. . Applications . Deep learning, a popular research area of artificial intelligence (AI), enables the creation of end-to-end models to achieve promised results using input data without the need for manual feature extraction. . | We have used CT scan images to not sacrifice the quality of diagnosis and improve the speed of data diagnosis. . | To combat COVID, the Current need of the hour is building Medical Diagnosis Support Systems that are Fast, Reliable, Efficient, and Effective. . | Conventional Covid-19 tests that, is PCR (Polymerase chain reaction) test are time-consuming and also leads to much more False-Negative and False Positive predictions . | We have to send the sample of PCR  to the labs, which are sometimes in faraway locations that  is far time consuming | Sometimes, When the doctors and Radiologists are not available at that time, we can   generate a preliminary diagnosis  | Application of machine learning methods for automatic diagnosis in the medical field have recently gained popularity, i.e., have become far more essential in early detection  | Fast and accurate diagnostic methods are heavily needed to combat the disease, so more and more time should be invested in Disease Control | . References . https://www.medrxiv.org/content/10.1101/2020.04.24.20078584v3 https://www.kaggle.com/plameneduardo/sarscov2-ctscan-dataset .",
            "url": "https://priyank7n.me/2021/01/20/Covify-GUI.html",
            "relUrl": "/2021/01/20/Covify-GUI.html",
            "date": " • Jan 20, 2021"
        }
        
    
  
    
  
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hey Fella👋 My Name is Priyank Negi. I am learning and exploring new stuff and writing about my interests in topics where AI skills could be leveraged and entrepreneurial opportunities could be created. I believe in learning by doing stuff instead of the conventional approach of learning everything but doing nothing! Lots of Experimentation and Project-based learning is what I go and by following these amazing courses curated by thefast ai team, Jeremy Howard and Syllvian Gugger made deep learning seem so easy to build stuff on top of our ideas, so I highly recommend checking out these courses as they are excellent to get started and advance in the field of AI. Thank you!! and u can reach me out on Twitter or on LinkedIn .",
          "url": "https://priyank7n.me/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://priyank7n.me/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}